// <auto-generated>
/*
 * Hydrus Client API
 *
 * API for interacting with the Hydrus Client
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization.Metadata;
using HydrusAPI.NET.Client;

namespace HydrusAPI.NET.Model
{
    /// <summary>
    /// FileRelationship
    /// </summary>
    public partial class FileRelationship : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FileRelationship" /> class.
        /// </summary>
        /// <param name="isKing">Whether this file is the king of its duplicate group.</param>
        /// <param name="king">The SHA256 hash of the king file of the group.</param>
        /// <param name="kingIsOnFileDomain">Whether the king file exists on the specified file domain.</param>
        /// <param name="kingIsLocal">Whether the king file is present on the local disk.</param>
        /// <param name="var0">List of potential duplicate hashes.</param>
        /// <param name="var1">List of false positive hashes.</param>
        /// <param name="var3">List of alternate hashes.</param>
        /// <param name="var8">List of duplicate hashes.</param>
        [JsonConstructor]
        public FileRelationship(bool isKing, string king, bool kingIsOnFileDomain, bool kingIsLocal, List<string> var0, List<string> var1, List<string> var3, List<string> var8)
        {
            IsKing = isKing;
            King = king;
            KingIsOnFileDomain = kingIsOnFileDomain;
            KingIsLocal = kingIsLocal;
            Var0 = var0;
            Var1 = var1;
            Var3 = var3;
            Var8 = var8;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Whether this file is the king of its duplicate group.
        /// </summary>
        /// <value>Whether this file is the king of its duplicate group.</value>
        [JsonPropertyName("is_king")]
        public bool IsKing { get; set; }

        /// <summary>
        /// The SHA256 hash of the king file of the group.
        /// </summary>
        /// <value>The SHA256 hash of the king file of the group.</value>
        /* <example>8784afbfd8b59de3dcf2c13dc1be9d7cb0b3d376803c8a7a8b710c7c191bb657</example> */
        [JsonPropertyName("king")]
        public string King { get; set; }

        /// <summary>
        /// Whether the king file exists on the specified file domain.
        /// </summary>
        /// <value>Whether the king file exists on the specified file domain.</value>
        [JsonPropertyName("king_is_on_file_domain")]
        public bool KingIsOnFileDomain { get; set; }

        /// <summary>
        /// Whether the king file is present on the local disk.
        /// </summary>
        /// <value>Whether the king file is present on the local disk.</value>
        [JsonPropertyName("king_is_local")]
        public bool KingIsLocal { get; set; }

        /// <summary>
        /// List of potential duplicate hashes.
        /// </summary>
        /// <value>List of potential duplicate hashes.</value>
        [JsonPropertyName("0")]
        public List<string> Var0 { get; set; }

        /// <summary>
        /// List of false positive hashes.
        /// </summary>
        /// <value>List of false positive hashes.</value>
        [JsonPropertyName("1")]
        public List<string> Var1 { get; set; }

        /// <summary>
        /// List of alternate hashes.
        /// </summary>
        /// <value>List of alternate hashes.</value>
        [JsonPropertyName("3")]
        public List<string> Var3 { get; set; }

        /// <summary>
        /// List of duplicate hashes.
        /// </summary>
        /// <value>List of duplicate hashes.</value>
        [JsonPropertyName("8")]
        public List<string> Var8 { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class FileRelationship {\n");
            sb.Append("  IsKing: ").Append(IsKing).Append("\n");
            sb.Append("  King: ").Append(King).Append("\n");
            sb.Append("  KingIsOnFileDomain: ").Append(KingIsOnFileDomain).Append("\n");
            sb.Append("  KingIsLocal: ").Append(KingIsLocal).Append("\n");
            sb.Append("  Var0: ").Append(Var0).Append("\n");
            sb.Append("  Var1: ").Append(Var1).Append("\n");
            sb.Append("  Var3: ").Append(Var3).Append("\n");
            sb.Append("  Var8: ").Append(Var8).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="FileRelationship" />
    /// </summary>
    public class FileRelationshipJsonConverter : JsonConverter<FileRelationship>
    {
        /// <summary>
        /// Deserializes json to <see cref="FileRelationship" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override FileRelationship Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<bool?> isKing = default;
            Option<string?> king = default;
            Option<bool?> kingIsOnFileDomain = default;
            Option<bool?> kingIsLocal = default;
            Option<List<string>?> var0 = default;
            Option<List<string>?> var1 = default;
            Option<List<string>?> var3 = default;
            Option<List<string>?> var8 = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "is_king":
                            isKing = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "king":
                            king = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "king_is_on_file_domain":
                            kingIsOnFileDomain = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "king_is_local":
                            kingIsLocal = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "0":
                            var0 = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "1":
                            var1 = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "3":
                            var3 = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "8":
                            var8 = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!isKing.IsSet)
                throw new ArgumentException("Property is required for class FileRelationship.", nameof(isKing));

            if (!king.IsSet)
                throw new ArgumentException("Property is required for class FileRelationship.", nameof(king));

            if (!kingIsOnFileDomain.IsSet)
                throw new ArgumentException("Property is required for class FileRelationship.", nameof(kingIsOnFileDomain));

            if (!kingIsLocal.IsSet)
                throw new ArgumentException("Property is required for class FileRelationship.", nameof(kingIsLocal));

            if (!var0.IsSet)
                throw new ArgumentException("Property is required for class FileRelationship.", nameof(var0));

            if (!var1.IsSet)
                throw new ArgumentException("Property is required for class FileRelationship.", nameof(var1));

            if (!var3.IsSet)
                throw new ArgumentException("Property is required for class FileRelationship.", nameof(var3));

            if (!var8.IsSet)
                throw new ArgumentException("Property is required for class FileRelationship.", nameof(var8));

            if (isKing.IsSet && isKing.Value == null)
                throw new ArgumentNullException(nameof(isKing), "Property is not nullable for class FileRelationship.");

            if (king.IsSet && king.Value == null)
                throw new ArgumentNullException(nameof(king), "Property is not nullable for class FileRelationship.");

            if (kingIsOnFileDomain.IsSet && kingIsOnFileDomain.Value == null)
                throw new ArgumentNullException(nameof(kingIsOnFileDomain), "Property is not nullable for class FileRelationship.");

            if (kingIsLocal.IsSet && kingIsLocal.Value == null)
                throw new ArgumentNullException(nameof(kingIsLocal), "Property is not nullable for class FileRelationship.");

            if (var0.IsSet && var0.Value == null)
                throw new ArgumentNullException(nameof(var0), "Property is not nullable for class FileRelationship.");

            if (var1.IsSet && var1.Value == null)
                throw new ArgumentNullException(nameof(var1), "Property is not nullable for class FileRelationship.");

            if (var3.IsSet && var3.Value == null)
                throw new ArgumentNullException(nameof(var3), "Property is not nullable for class FileRelationship.");

            if (var8.IsSet && var8.Value == null)
                throw new ArgumentNullException(nameof(var8), "Property is not nullable for class FileRelationship.");

            return new FileRelationship(isKing.Value!.Value!, king.Value!, kingIsOnFileDomain.Value!.Value!, kingIsLocal.Value!.Value!, var0.Value!, var1.Value!, var3.Value!, var8.Value!);
        }

        /// <summary>
        /// Serializes a <see cref="FileRelationship" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="fileRelationship"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, FileRelationship fileRelationship, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, fileRelationship, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="FileRelationship" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="fileRelationship"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, FileRelationship fileRelationship, JsonSerializerOptions jsonSerializerOptions)
        {
            if (fileRelationship.King == null)
                throw new ArgumentNullException(nameof(fileRelationship.King), "Property is required for class FileRelationship.");

            if (fileRelationship.Var0 == null)
                throw new ArgumentNullException(nameof(fileRelationship.Var0), "Property is required for class FileRelationship.");

            if (fileRelationship.Var1 == null)
                throw new ArgumentNullException(nameof(fileRelationship.Var1), "Property is required for class FileRelationship.");

            if (fileRelationship.Var3 == null)
                throw new ArgumentNullException(nameof(fileRelationship.Var3), "Property is required for class FileRelationship.");

            if (fileRelationship.Var8 == null)
                throw new ArgumentNullException(nameof(fileRelationship.Var8), "Property is required for class FileRelationship.");

            writer.WriteBoolean("is_king", fileRelationship.IsKing);

            writer.WriteString("king", fileRelationship.King);

            writer.WriteBoolean("king_is_on_file_domain", fileRelationship.KingIsOnFileDomain);

            writer.WriteBoolean("king_is_local", fileRelationship.KingIsLocal);

            writer.WritePropertyName("0");
            JsonSerializer.Serialize(writer, fileRelationship.Var0, jsonSerializerOptions);
            writer.WritePropertyName("1");
            JsonSerializer.Serialize(writer, fileRelationship.Var1, jsonSerializerOptions);
            writer.WritePropertyName("3");
            JsonSerializer.Serialize(writer, fileRelationship.Var3, jsonSerializerOptions);
            writer.WritePropertyName("8");
            JsonSerializer.Serialize(writer, fileRelationship.Var8, jsonSerializerOptions);
        }
    }

    /// <summary>
    /// The FileRelationshipSerializationContext
    /// </summary>
    [JsonSourceGenerationOptions(WriteIndented = true, GenerationMode = JsonSourceGenerationMode.Metadata | JsonSourceGenerationMode.Serialization)]
    [JsonSerializable(typeof(FileRelationship))]
    public partial class FileRelationshipSerializationContext : JsonSerializerContext { }
}
