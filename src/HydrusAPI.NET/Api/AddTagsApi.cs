// <auto-generated>
/*
 * Hydrus Client API
 *
 * API for interacting with the Hydrus Client
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using HydrusAPI.NET.Client;
using HydrusAPI.NET.Model;
using System.Diagnostics.CodeAnalysis;

namespace HydrusAPI.NET.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IAddTagsApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        AddTagsApiEvents Events { get; }

        /// <summary>
        /// Add or modify tags for files
        /// </summary>
        /// <remarks>
        /// Adds, deletes, pends, or petitions tags for specified files. Requires Add Tags permission.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="addTagsAddTagsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsAddTagsApiResponse"/>&gt;</returns>
        Task<IAddTagsAddTagsApiResponse> AddTagsAddTagsAsync(AddTagsAddTagsRequest addTagsAddTagsRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Add or modify tags for files
        /// </summary>
        /// <remarks>
        /// Adds, deletes, pends, or petitions tags for specified files. Requires Add Tags permission.
        /// </remarks>
        /// <param name="addTagsAddTagsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsAddTagsApiResponse"/>?&gt;</returns>
        Task<IAddTagsAddTagsApiResponse?> AddTagsAddTagsOrDefaultAsync(AddTagsAddTagsRequest addTagsAddTagsRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Clean tags according to Hydrus rules
        /// </summary>
        /// <remarks>
        /// Asks the client to clean and normalize a list of tags according to its internal rules. This can be useful for ensuring tags are in a consistent format before applying them to files. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tags">A list of tags to be cleaned.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsCleanTagsApiResponse"/>&gt;</returns>
        Task<IAddTagsCleanTagsApiResponse> AddTagsCleanTagsAsync(List<string> tags, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Clean tags according to Hydrus rules
        /// </summary>
        /// <remarks>
        /// Asks the client to clean and normalize a list of tags according to its internal rules. This can be useful for ensuring tags are in a consistent format before applying them to files. 
        /// </remarks>
        /// <param name="tags">A list of tags to be cleaned.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsCleanTagsApiResponse"/>?&gt;</returns>
        Task<IAddTagsCleanTagsApiResponse?> AddTagsCleanTagsOrDefaultAsync(List<string> tags, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Fetch the client&#39;s favourite tags.
        /// </summary>
        /// <remarks>
        /// Fetches a list of favourite tags as displayed in the client UI under the &#39;favourites&#39; tab.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsGetFavouriteTagsApiResponse"/>&gt;</returns>
        Task<IAddTagsGetFavouriteTagsApiResponse> AddTagsGetFavouriteTagsAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Fetch the client&#39;s favourite tags.
        /// </summary>
        /// <remarks>
        /// Fetches a list of favourite tags as displayed in the client UI under the &#39;favourites&#39; tab.
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsGetFavouriteTagsApiResponse"/>?&gt;</returns>
        Task<IAddTagsGetFavouriteTagsApiResponse?> AddTagsGetFavouriteTagsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get sibling and parent relationships for tags
        /// </summary>
        /// <remarks>
        /// Ask the client about tags&#39; sibling and parent relationships.  !!! warning \&quot;Tag Relationships Apply In A Complicated Way\&quot;     There are two caveats to this data:            1. The siblings and parents here are not just what is in _tags-&gt;manage tag siblings/parents_, they are the final computed combination of rules as set in _tags-&gt;manage where tag siblings and parents apply_. The data given here is not guaranteed to be useful for editing siblings and parents on a particular service. That data, which is currently pair-based, will appear in a different API request in future.     2. This is what is _actually processed, right now,_ for those user preferences, as per _tags-&gt;sibling/parent sync-&gt;review current sync_. It reflects what they currently see in the UI. If the user still has pending sync work, this computation will change in future, perhaps radically (e.g. if they just removed the whole PTR ruleset two minutes ago), as will the rest of the \&quot;display\&quot; domain. The results may be funky while a user is in the midst of syncing, but these values are fine for most purposes. In the short term, you can broadly assume that the rules here very closely align with what you see in a recent file metadata call that pulls storage vs display mappings. If you want to decorate an autocomplete results call with sibling or parent data, this data is good for that. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tags">A list of the tags you want info on</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsGetSiblingsAndParentsApiResponse"/>&gt;</returns>
        Task<IAddTagsGetSiblingsAndParentsApiResponse> AddTagsGetSiblingsAndParentsAsync(List<string> tags, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get sibling and parent relationships for tags
        /// </summary>
        /// <remarks>
        /// Ask the client about tags&#39; sibling and parent relationships.  !!! warning \&quot;Tag Relationships Apply In A Complicated Way\&quot;     There are two caveats to this data:            1. The siblings and parents here are not just what is in _tags-&gt;manage tag siblings/parents_, they are the final computed combination of rules as set in _tags-&gt;manage where tag siblings and parents apply_. The data given here is not guaranteed to be useful for editing siblings and parents on a particular service. That data, which is currently pair-based, will appear in a different API request in future.     2. This is what is _actually processed, right now,_ for those user preferences, as per _tags-&gt;sibling/parent sync-&gt;review current sync_. It reflects what they currently see in the UI. If the user still has pending sync work, this computation will change in future, perhaps radically (e.g. if they just removed the whole PTR ruleset two minutes ago), as will the rest of the \&quot;display\&quot; domain. The results may be funky while a user is in the midst of syncing, but these values are fine for most purposes. In the short term, you can broadly assume that the rules here very closely align with what you see in a recent file metadata call that pulls storage vs display mappings. If you want to decorate an autocomplete results call with sibling or parent data, this data is good for that. 
        /// </remarks>
        /// <param name="tags">A list of the tags you want info on</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsGetSiblingsAndParentsApiResponse"/>?&gt;</returns>
        Task<IAddTagsGetSiblingsAndParentsApiResponse?> AddTagsGetSiblingsAndParentsOrDefaultAsync(List<string> tags, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search the client for tags.
        /// </summary>
        /// <remarks>
        /// Search the client for tags based on the provided query and optional file/tag domain filters.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="search">The tag text to search for, enter exactly what you would in the client UI.</param>
        /// <param name="fileServiceKey">The file service key to limit the search to specific files. (optional)</param>
        /// <param name="fileServiceKeys">A list of file service keys to limit the search to specific files. (optional)</param>
        /// <param name="deletedFileServiceKey">The file service key to search for files deleted from this domain. (optional)</param>
        /// <param name="deletedFileServiceKeys">A list of file service keys to search for files deleted from specific domains. (optional)</param>
        /// <param name="tagServiceKey">The tag service key to limit the search to specific tags. (optional)</param>
        /// <param name="tagDisplayType">Whether to search raw (&#x60;storage&#x60;) or sibling-processed (&#x60;display&#x60;) tags. (optional)</param>
        /// <param name="hydrusClientAPIAccessKey">Permanent access key for authentication. (optional)</param>
        /// <param name="hydrusClientAPISessionKey">Temporary session key for authentication. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsSearchTagsApiResponse"/>&gt;</returns>
        Task<IAddTagsSearchTagsApiResponse> AddTagsSearchTagsAsync(string search, Option<string> fileServiceKey = default, Option<List<string>> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<List<string>> deletedFileServiceKeys = default, Option<string> tagServiceKey = default, Option<string> tagDisplayType = default, Option<string> hydrusClientAPIAccessKey = default, Option<string> hydrusClientAPISessionKey = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search the client for tags.
        /// </summary>
        /// <remarks>
        /// Search the client for tags based on the provided query and optional file/tag domain filters.
        /// </remarks>
        /// <param name="search">The tag text to search for, enter exactly what you would in the client UI.</param>
        /// <param name="fileServiceKey">The file service key to limit the search to specific files. (optional)</param>
        /// <param name="fileServiceKeys">A list of file service keys to limit the search to specific files. (optional)</param>
        /// <param name="deletedFileServiceKey">The file service key to search for files deleted from this domain. (optional)</param>
        /// <param name="deletedFileServiceKeys">A list of file service keys to search for files deleted from specific domains. (optional)</param>
        /// <param name="tagServiceKey">The tag service key to limit the search to specific tags. (optional)</param>
        /// <param name="tagDisplayType">Whether to search raw (&#x60;storage&#x60;) or sibling-processed (&#x60;display&#x60;) tags. (optional)</param>
        /// <param name="hydrusClientAPIAccessKey">Permanent access key for authentication. (optional)</param>
        /// <param name="hydrusClientAPISessionKey">Temporary session key for authentication. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsSearchTagsApiResponse"/>?&gt;</returns>
        Task<IAddTagsSearchTagsApiResponse?> AddTagsSearchTagsOrDefaultAsync(string search, Option<string> fileServiceKey = default, Option<List<string>> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<List<string>> deletedFileServiceKeys = default, Option<string> tagServiceKey = default, Option<string> tagDisplayType = default, Option<string> hydrusClientAPIAccessKey = default, Option<string> hydrusClientAPISessionKey = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set or modify the client&#39;s favourite tags
        /// </summary>
        /// <remarks>
        /// Edits the client&#39;s list of favourite tags either by setting a new list entirely or modifying the existing list with additions or removals.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="addTagsSetFavouriteTagsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsSetFavouriteTagsApiResponse"/>&gt;</returns>
        Task<IAddTagsSetFavouriteTagsApiResponse> AddTagsSetFavouriteTagsAsync(AddTagsSetFavouriteTagsRequest addTagsSetFavouriteTagsRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set or modify the client&#39;s favourite tags
        /// </summary>
        /// <remarks>
        /// Edits the client&#39;s list of favourite tags either by setting a new list entirely or modifying the existing list with additions or removals.
        /// </remarks>
        /// <param name="addTagsSetFavouriteTagsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsSetFavouriteTagsApiResponse"/>?&gt;</returns>
        Task<IAddTagsSetFavouriteTagsApiResponse?> AddTagsSetFavouriteTagsOrDefaultAsync(AddTagsSetFavouriteTagsRequest addTagsSetFavouriteTagsRequest, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IAddTagsAddTagsApiResponse"/>
    /// </summary>
    public interface IAddTagsAddTagsApiResponse : HydrusAPI.NET.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 419 CustomHttpStatusCode419
        /// </summary>
        /// <returns></returns>
        bool IsCustomHttpStatusCode419 { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IAddTagsCleanTagsApiResponse"/>
    /// </summary>
    public interface IAddTagsCleanTagsApiResponse : HydrusAPI.NET.Client.IApiResponse, IOk<HydrusAPI.NET.Model.AddTagsCleanTags200Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 419 CustomHttpStatusCode419
        /// </summary>
        /// <returns></returns>
        bool IsCustomHttpStatusCode419 { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IAddTagsGetFavouriteTagsApiResponse"/>
    /// </summary>
    public interface IAddTagsGetFavouriteTagsApiResponse : HydrusAPI.NET.Client.IApiResponse, IOk<HydrusAPI.NET.Model.AddTagsGetFavouriteTags200Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IAddTagsGetSiblingsAndParentsApiResponse"/>
    /// </summary>
    public interface IAddTagsGetSiblingsAndParentsApiResponse : HydrusAPI.NET.Client.IApiResponse, IOk<HydrusAPI.NET.Model.GetSiblingsAndParentsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 419 CustomHttpStatusCode419
        /// </summary>
        /// <returns></returns>
        bool IsCustomHttpStatusCode419 { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IAddTagsSearchTagsApiResponse"/>
    /// </summary>
    public interface IAddTagsSearchTagsApiResponse : HydrusAPI.NET.Client.IApiResponse, IOk<HydrusAPI.NET.Model.AddTagsSearchTags200Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 419 CustomHttpStatusCode419
        /// </summary>
        /// <returns></returns>
        bool IsCustomHttpStatusCode419 { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IAddTagsSetFavouriteTagsApiResponse"/>
    /// </summary>
    public interface IAddTagsSetFavouriteTagsApiResponse : HydrusAPI.NET.Client.IApiResponse, IOk<HydrusAPI.NET.Model.AddTagsSetFavouriteTags200Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 419 CustomHttpStatusCode419
        /// </summary>
        /// <returns></returns>
        bool IsCustomHttpStatusCode419 { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class AddTagsApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAddTagsAddTags;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAddTagsAddTags;

        internal void ExecuteOnAddTagsAddTags(AddTagsApi.AddTagsAddTagsApiResponse apiResponse)
        {
            OnAddTagsAddTags?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAddTagsAddTags(Exception exception)
        {
            OnErrorAddTagsAddTags?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAddTagsCleanTags;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAddTagsCleanTags;

        internal void ExecuteOnAddTagsCleanTags(AddTagsApi.AddTagsCleanTagsApiResponse apiResponse)
        {
            OnAddTagsCleanTags?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAddTagsCleanTags(Exception exception)
        {
            OnErrorAddTagsCleanTags?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAddTagsGetFavouriteTags;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAddTagsGetFavouriteTags;

        internal void ExecuteOnAddTagsGetFavouriteTags(AddTagsApi.AddTagsGetFavouriteTagsApiResponse apiResponse)
        {
            OnAddTagsGetFavouriteTags?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAddTagsGetFavouriteTags(Exception exception)
        {
            OnErrorAddTagsGetFavouriteTags?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAddTagsGetSiblingsAndParents;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAddTagsGetSiblingsAndParents;

        internal void ExecuteOnAddTagsGetSiblingsAndParents(AddTagsApi.AddTagsGetSiblingsAndParentsApiResponse apiResponse)
        {
            OnAddTagsGetSiblingsAndParents?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAddTagsGetSiblingsAndParents(Exception exception)
        {
            OnErrorAddTagsGetSiblingsAndParents?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAddTagsSearchTags;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAddTagsSearchTags;

        internal void ExecuteOnAddTagsSearchTags(AddTagsApi.AddTagsSearchTagsApiResponse apiResponse)
        {
            OnAddTagsSearchTags?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAddTagsSearchTags(Exception exception)
        {
            OnErrorAddTagsSearchTags?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAddTagsSetFavouriteTags;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAddTagsSetFavouriteTags;

        internal void ExecuteOnAddTagsSetFavouriteTags(AddTagsApi.AddTagsSetFavouriteTagsApiResponse apiResponse)
        {
            OnAddTagsSetFavouriteTags?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAddTagsSetFavouriteTags(Exception exception)
        {
            OnErrorAddTagsSetFavouriteTags?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class AddTagsApi : IAddTagsApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<AddTagsApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public AddTagsApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="AddTagsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public AddTagsApi(ILogger<AddTagsApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, AddTagsApiEvents addTagsApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<AddTagsApi>();
            HttpClient = httpClient;
            Events = addTagsApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatAddTagsAddTags(AddTagsAddTagsRequest addTagsAddTagsRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="addTagsAddTagsRequest"></param>
        /// <returns></returns>
        private void ValidateAddTagsAddTags(AddTagsAddTagsRequest addTagsAddTagsRequest)
        {
            if (addTagsAddTagsRequest == null)
                throw new ArgumentNullException(nameof(addTagsAddTagsRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="addTagsAddTagsRequest"></param>
        private void AfterAddTagsAddTagsDefaultImplementation(IAddTagsAddTagsApiResponse apiResponseLocalVar, AddTagsAddTagsRequest addTagsAddTagsRequest)
        {
            bool suppressDefaultLog = false;
            AfterAddTagsAddTags(ref suppressDefaultLog, apiResponseLocalVar, addTagsAddTagsRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="addTagsAddTagsRequest"></param>
        partial void AfterAddTagsAddTags(ref bool suppressDefaultLog, IAddTagsAddTagsApiResponse apiResponseLocalVar, AddTagsAddTagsRequest addTagsAddTagsRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="addTagsAddTagsRequest"></param>
        private void OnErrorAddTagsAddTagsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, AddTagsAddTagsRequest addTagsAddTagsRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAddTagsAddTags(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, addTagsAddTagsRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="addTagsAddTagsRequest"></param>
        partial void OnErrorAddTagsAddTags(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, AddTagsAddTagsRequest addTagsAddTagsRequest);

        /// <summary>
        /// Add or modify tags for files Adds, deletes, pends, or petitions tags for specified files. Requires Add Tags permission.
        /// </summary>
        /// <param name="addTagsAddTagsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsAddTagsApiResponse"/>&gt;</returns>
        public async Task<IAddTagsAddTagsApiResponse?> AddTagsAddTagsOrDefaultAsync(AddTagsAddTagsRequest addTagsAddTagsRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AddTagsAddTagsAsync(addTagsAddTagsRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Add or modify tags for files Adds, deletes, pends, or petitions tags for specified files. Requires Add Tags permission.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="addTagsAddTagsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsAddTagsApiResponse"/>&gt;</returns>
        public async Task<IAddTagsAddTagsApiResponse> AddTagsAddTagsAsync(AddTagsAddTagsRequest addTagsAddTagsRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAddTagsAddTags(addTagsAddTagsRequest);

                FormatAddTagsAddTags(addTagsAddTagsRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/add_tags/add_tags"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/add_tags/add_tags");

                    httpRequestMessageLocalVar.Content = (addTagsAddTagsRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(addTagsAddTagsRequest, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Access-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Session-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<AddTagsAddTagsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AddTagsAddTagsApiResponse>();
                        AddTagsAddTagsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/add_tags/add_tags", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterAddTagsAddTagsDefaultImplementation(apiResponseLocalVar, addTagsAddTagsRequest);

                        Events.ExecuteOnAddTagsAddTags(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAddTagsAddTagsDefaultImplementation(e, "/add_tags/add_tags", uriBuilderLocalVar.Path, addTagsAddTagsRequest);
                Events.ExecuteOnErrorAddTagsAddTags(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AddTagsAddTagsApiResponse"/>
        /// </summary>
        public partial class AddTagsAddTagsApiResponse : HydrusAPI.NET.Client.ApiResponse, IAddTagsAddTagsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AddTagsAddTagsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AddTagsAddTagsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddTagsAddTagsApiResponse(ILogger<AddTagsAddTagsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="AddTagsAddTagsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddTagsAddTagsApiResponse(ILogger<AddTagsAddTagsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 419 CustomHttpStatusCode419
            /// </summary>
            /// <returns></returns>
            public bool IsCustomHttpStatusCode419 => 419 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatAddTagsCleanTags(List<string> tags);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="tags"></param>
        /// <returns></returns>
        private void ValidateAddTagsCleanTags(List<string> tags)
        {
            if (tags == null)
                throw new ArgumentNullException(nameof(tags));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tags"></param>
        private void AfterAddTagsCleanTagsDefaultImplementation(IAddTagsCleanTagsApiResponse apiResponseLocalVar, List<string> tags)
        {
            bool suppressDefaultLog = false;
            AfterAddTagsCleanTags(ref suppressDefaultLog, apiResponseLocalVar, tags);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tags"></param>
        partial void AfterAddTagsCleanTags(ref bool suppressDefaultLog, IAddTagsCleanTagsApiResponse apiResponseLocalVar, List<string> tags);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="tags"></param>
        private void OnErrorAddTagsCleanTagsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<string> tags)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAddTagsCleanTags(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, tags);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="tags"></param>
        partial void OnErrorAddTagsCleanTags(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<string> tags);

        /// <summary>
        /// Clean tags according to Hydrus rules Asks the client to clean and normalize a list of tags according to its internal rules. This can be useful for ensuring tags are in a consistent format before applying them to files. 
        /// </summary>
        /// <param name="tags">A list of tags to be cleaned.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsCleanTagsApiResponse"/>&gt;</returns>
        public async Task<IAddTagsCleanTagsApiResponse?> AddTagsCleanTagsOrDefaultAsync(List<string> tags, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AddTagsCleanTagsAsync(tags, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Clean tags according to Hydrus rules Asks the client to clean and normalize a list of tags according to its internal rules. This can be useful for ensuring tags are in a consistent format before applying them to files. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tags">A list of tags to be cleaned.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsCleanTagsApiResponse"/>&gt;</returns>
        public async Task<IAddTagsCleanTagsApiResponse> AddTagsCleanTagsAsync(List<string> tags, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAddTagsCleanTags(tags);

                FormatAddTagsCleanTags(tags);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/add_tags/clean_tags"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/add_tags/clean_tags");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["tags"] = ClientUtils.ParameterToString(tags);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Access-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Session-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<AddTagsCleanTagsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AddTagsCleanTagsApiResponse>();
                        AddTagsCleanTagsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/add_tags/clean_tags", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterAddTagsCleanTagsDefaultImplementation(apiResponseLocalVar, tags);

                        Events.ExecuteOnAddTagsCleanTags(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAddTagsCleanTagsDefaultImplementation(e, "/add_tags/clean_tags", uriBuilderLocalVar.Path, tags);
                Events.ExecuteOnErrorAddTagsCleanTags(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AddTagsCleanTagsApiResponse"/>
        /// </summary>
        public partial class AddTagsCleanTagsApiResponse : HydrusAPI.NET.Client.ApiResponse, IAddTagsCleanTagsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AddTagsCleanTagsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AddTagsCleanTagsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddTagsCleanTagsApiResponse(ILogger<AddTagsCleanTagsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="AddTagsCleanTagsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddTagsCleanTagsApiResponse(ILogger<AddTagsCleanTagsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public HydrusAPI.NET.Model.AddTagsCleanTags200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<HydrusAPI.NET.Model.AddTagsCleanTags200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out HydrusAPI.NET.Model.AddTagsCleanTags200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 419 CustomHttpStatusCode419
            /// </summary>
            /// <returns></returns>
            public bool IsCustomHttpStatusCode419 => 419 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterAddTagsGetFavouriteTagsDefaultImplementation(IAddTagsGetFavouriteTagsApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterAddTagsGetFavouriteTags(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterAddTagsGetFavouriteTags(ref bool suppressDefaultLog, IAddTagsGetFavouriteTagsApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorAddTagsGetFavouriteTagsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAddTagsGetFavouriteTags(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorAddTagsGetFavouriteTags(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Fetch the client&#39;s favourite tags. Fetches a list of favourite tags as displayed in the client UI under the &#39;favourites&#39; tab.
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsGetFavouriteTagsApiResponse"/>&gt;</returns>
        public async Task<IAddTagsGetFavouriteTagsApiResponse?> AddTagsGetFavouriteTagsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AddTagsGetFavouriteTagsAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Fetch the client&#39;s favourite tags. Fetches a list of favourite tags as displayed in the client UI under the &#39;favourites&#39; tab.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsGetFavouriteTagsApiResponse"/>&gt;</returns>
        public async Task<IAddTagsGetFavouriteTagsApiResponse> AddTagsGetFavouriteTagsAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/add_tags/get_favourite_tags"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/add_tags/get_favourite_tags");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Access-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Session-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<AddTagsGetFavouriteTagsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AddTagsGetFavouriteTagsApiResponse>();
                        AddTagsGetFavouriteTagsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/add_tags/get_favourite_tags", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterAddTagsGetFavouriteTagsDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnAddTagsGetFavouriteTags(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAddTagsGetFavouriteTagsDefaultImplementation(e, "/add_tags/get_favourite_tags", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorAddTagsGetFavouriteTags(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AddTagsGetFavouriteTagsApiResponse"/>
        /// </summary>
        public partial class AddTagsGetFavouriteTagsApiResponse : HydrusAPI.NET.Client.ApiResponse, IAddTagsGetFavouriteTagsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AddTagsGetFavouriteTagsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AddTagsGetFavouriteTagsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddTagsGetFavouriteTagsApiResponse(ILogger<AddTagsGetFavouriteTagsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="AddTagsGetFavouriteTagsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddTagsGetFavouriteTagsApiResponse(ILogger<AddTagsGetFavouriteTagsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public HydrusAPI.NET.Model.AddTagsGetFavouriteTags200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<HydrusAPI.NET.Model.AddTagsGetFavouriteTags200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out HydrusAPI.NET.Model.AddTagsGetFavouriteTags200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatAddTagsGetSiblingsAndParents(List<string> tags);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="tags"></param>
        /// <returns></returns>
        private void ValidateAddTagsGetSiblingsAndParents(List<string> tags)
        {
            if (tags == null)
                throw new ArgumentNullException(nameof(tags));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tags"></param>
        private void AfterAddTagsGetSiblingsAndParentsDefaultImplementation(IAddTagsGetSiblingsAndParentsApiResponse apiResponseLocalVar, List<string> tags)
        {
            bool suppressDefaultLog = false;
            AfterAddTagsGetSiblingsAndParents(ref suppressDefaultLog, apiResponseLocalVar, tags);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tags"></param>
        partial void AfterAddTagsGetSiblingsAndParents(ref bool suppressDefaultLog, IAddTagsGetSiblingsAndParentsApiResponse apiResponseLocalVar, List<string> tags);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="tags"></param>
        private void OnErrorAddTagsGetSiblingsAndParentsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<string> tags)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAddTagsGetSiblingsAndParents(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, tags);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="tags"></param>
        partial void OnErrorAddTagsGetSiblingsAndParents(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<string> tags);

        /// <summary>
        /// Get sibling and parent relationships for tags Ask the client about tags&#39; sibling and parent relationships.  !!! warning \&quot;Tag Relationships Apply In A Complicated Way\&quot;     There are two caveats to this data:            1. The siblings and parents here are not just what is in _tags-&gt;manage tag siblings/parents_, they are the final computed combination of rules as set in _tags-&gt;manage where tag siblings and parents apply_. The data given here is not guaranteed to be useful for editing siblings and parents on a particular service. That data, which is currently pair-based, will appear in a different API request in future.     2. This is what is _actually processed, right now,_ for those user preferences, as per _tags-&gt;sibling/parent sync-&gt;review current sync_. It reflects what they currently see in the UI. If the user still has pending sync work, this computation will change in future, perhaps radically (e.g. if they just removed the whole PTR ruleset two minutes ago), as will the rest of the \&quot;display\&quot; domain. The results may be funky while a user is in the midst of syncing, but these values are fine for most purposes. In the short term, you can broadly assume that the rules here very closely align with what you see in a recent file metadata call that pulls storage vs display mappings. If you want to decorate an autocomplete results call with sibling or parent data, this data is good for that. 
        /// </summary>
        /// <param name="tags">A list of the tags you want info on</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsGetSiblingsAndParentsApiResponse"/>&gt;</returns>
        public async Task<IAddTagsGetSiblingsAndParentsApiResponse?> AddTagsGetSiblingsAndParentsOrDefaultAsync(List<string> tags, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AddTagsGetSiblingsAndParentsAsync(tags, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get sibling and parent relationships for tags Ask the client about tags&#39; sibling and parent relationships.  !!! warning \&quot;Tag Relationships Apply In A Complicated Way\&quot;     There are two caveats to this data:            1. The siblings and parents here are not just what is in _tags-&gt;manage tag siblings/parents_, they are the final computed combination of rules as set in _tags-&gt;manage where tag siblings and parents apply_. The data given here is not guaranteed to be useful for editing siblings and parents on a particular service. That data, which is currently pair-based, will appear in a different API request in future.     2. This is what is _actually processed, right now,_ for those user preferences, as per _tags-&gt;sibling/parent sync-&gt;review current sync_. It reflects what they currently see in the UI. If the user still has pending sync work, this computation will change in future, perhaps radically (e.g. if they just removed the whole PTR ruleset two minutes ago), as will the rest of the \&quot;display\&quot; domain. The results may be funky while a user is in the midst of syncing, but these values are fine for most purposes. In the short term, you can broadly assume that the rules here very closely align with what you see in a recent file metadata call that pulls storage vs display mappings. If you want to decorate an autocomplete results call with sibling or parent data, this data is good for that. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tags">A list of the tags you want info on</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsGetSiblingsAndParentsApiResponse"/>&gt;</returns>
        public async Task<IAddTagsGetSiblingsAndParentsApiResponse> AddTagsGetSiblingsAndParentsAsync(List<string> tags, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAddTagsGetSiblingsAndParents(tags);

                FormatAddTagsGetSiblingsAndParents(tags);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/add_tags/get_siblings_and_parents"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/add_tags/get_siblings_and_parents");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["tags"] = ClientUtils.ParameterToString(tags);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Access-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Session-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<AddTagsGetSiblingsAndParentsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AddTagsGetSiblingsAndParentsApiResponse>();
                        AddTagsGetSiblingsAndParentsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/add_tags/get_siblings_and_parents", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterAddTagsGetSiblingsAndParentsDefaultImplementation(apiResponseLocalVar, tags);

                        Events.ExecuteOnAddTagsGetSiblingsAndParents(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAddTagsGetSiblingsAndParentsDefaultImplementation(e, "/add_tags/get_siblings_and_parents", uriBuilderLocalVar.Path, tags);
                Events.ExecuteOnErrorAddTagsGetSiblingsAndParents(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AddTagsGetSiblingsAndParentsApiResponse"/>
        /// </summary>
        public partial class AddTagsGetSiblingsAndParentsApiResponse : HydrusAPI.NET.Client.ApiResponse, IAddTagsGetSiblingsAndParentsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AddTagsGetSiblingsAndParentsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AddTagsGetSiblingsAndParentsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddTagsGetSiblingsAndParentsApiResponse(ILogger<AddTagsGetSiblingsAndParentsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="AddTagsGetSiblingsAndParentsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddTagsGetSiblingsAndParentsApiResponse(ILogger<AddTagsGetSiblingsAndParentsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public HydrusAPI.NET.Model.GetSiblingsAndParentsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<HydrusAPI.NET.Model.GetSiblingsAndParentsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out HydrusAPI.NET.Model.GetSiblingsAndParentsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 419 CustomHttpStatusCode419
            /// </summary>
            /// <returns></returns>
            public bool IsCustomHttpStatusCode419 => 419 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatAddTagsSearchTags(ref string search, ref Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, ref Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, ref Option<string> tagServiceKey, ref Option<string> tagDisplayType, ref Option<string> hydrusClientAPIAccessKey, ref Option<string> hydrusClientAPISessionKey);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="search"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey"></param>
        /// <param name="tagDisplayType"></param>
        /// <param name="hydrusClientAPIAccessKey"></param>
        /// <param name="hydrusClientAPISessionKey"></param>
        /// <returns></returns>
        private void ValidateAddTagsSearchTags(string search, Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey, Option<string> tagDisplayType, Option<string> hydrusClientAPIAccessKey, Option<string> hydrusClientAPISessionKey)
        {
            if (search == null)
                throw new ArgumentNullException(nameof(search));

            if (fileServiceKey.IsSet && fileServiceKey.Value == null)
                throw new ArgumentNullException(nameof(fileServiceKey));

            if (fileServiceKeys.IsSet && fileServiceKeys.Value == null)
                throw new ArgumentNullException(nameof(fileServiceKeys));

            if (deletedFileServiceKey.IsSet && deletedFileServiceKey.Value == null)
                throw new ArgumentNullException(nameof(deletedFileServiceKey));

            if (deletedFileServiceKeys.IsSet && deletedFileServiceKeys.Value == null)
                throw new ArgumentNullException(nameof(deletedFileServiceKeys));

            if (tagServiceKey.IsSet && tagServiceKey.Value == null)
                throw new ArgumentNullException(nameof(tagServiceKey));

            if (tagDisplayType.IsSet && tagDisplayType.Value == null)
                throw new ArgumentNullException(nameof(tagDisplayType));

            if (hydrusClientAPIAccessKey.IsSet && hydrusClientAPIAccessKey.Value == null)
                throw new ArgumentNullException(nameof(hydrusClientAPIAccessKey));

            if (hydrusClientAPISessionKey.IsSet && hydrusClientAPISessionKey.Value == null)
                throw new ArgumentNullException(nameof(hydrusClientAPISessionKey));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="search"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey"></param>
        /// <param name="tagDisplayType"></param>
        /// <param name="hydrusClientAPIAccessKey"></param>
        /// <param name="hydrusClientAPISessionKey"></param>
        private void AfterAddTagsSearchTagsDefaultImplementation(IAddTagsSearchTagsApiResponse apiResponseLocalVar, string search, Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey, Option<string> tagDisplayType, Option<string> hydrusClientAPIAccessKey, Option<string> hydrusClientAPISessionKey)
        {
            bool suppressDefaultLog = false;
            AfterAddTagsSearchTags(ref suppressDefaultLog, apiResponseLocalVar, search, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey, tagDisplayType, hydrusClientAPIAccessKey, hydrusClientAPISessionKey);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="search"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey"></param>
        /// <param name="tagDisplayType"></param>
        /// <param name="hydrusClientAPIAccessKey"></param>
        /// <param name="hydrusClientAPISessionKey"></param>
        partial void AfterAddTagsSearchTags(ref bool suppressDefaultLog, IAddTagsSearchTagsApiResponse apiResponseLocalVar, string search, Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey, Option<string> tagDisplayType, Option<string> hydrusClientAPIAccessKey, Option<string> hydrusClientAPISessionKey);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="search"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey"></param>
        /// <param name="tagDisplayType"></param>
        /// <param name="hydrusClientAPIAccessKey"></param>
        /// <param name="hydrusClientAPISessionKey"></param>
        private void OnErrorAddTagsSearchTagsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string search, Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey, Option<string> tagDisplayType, Option<string> hydrusClientAPIAccessKey, Option<string> hydrusClientAPISessionKey)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAddTagsSearchTags(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, search, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey, tagDisplayType, hydrusClientAPIAccessKey, hydrusClientAPISessionKey);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="search"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey"></param>
        /// <param name="tagDisplayType"></param>
        /// <param name="hydrusClientAPIAccessKey"></param>
        /// <param name="hydrusClientAPISessionKey"></param>
        partial void OnErrorAddTagsSearchTags(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string search, Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey, Option<string> tagDisplayType, Option<string> hydrusClientAPIAccessKey, Option<string> hydrusClientAPISessionKey);

        /// <summary>
        /// Search the client for tags. Search the client for tags based on the provided query and optional file/tag domain filters.
        /// </summary>
        /// <param name="search">The tag text to search for, enter exactly what you would in the client UI.</param>
        /// <param name="fileServiceKey">The file service key to limit the search to specific files. (optional)</param>
        /// <param name="fileServiceKeys">A list of file service keys to limit the search to specific files. (optional)</param>
        /// <param name="deletedFileServiceKey">The file service key to search for files deleted from this domain. (optional)</param>
        /// <param name="deletedFileServiceKeys">A list of file service keys to search for files deleted from specific domains. (optional)</param>
        /// <param name="tagServiceKey">The tag service key to limit the search to specific tags. (optional)</param>
        /// <param name="tagDisplayType">Whether to search raw (&#x60;storage&#x60;) or sibling-processed (&#x60;display&#x60;) tags. (optional)</param>
        /// <param name="hydrusClientAPIAccessKey">Permanent access key for authentication. (optional)</param>
        /// <param name="hydrusClientAPISessionKey">Temporary session key for authentication. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsSearchTagsApiResponse"/>&gt;</returns>
        public async Task<IAddTagsSearchTagsApiResponse?> AddTagsSearchTagsOrDefaultAsync(string search, Option<string> fileServiceKey = default, Option<List<string>> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<List<string>> deletedFileServiceKeys = default, Option<string> tagServiceKey = default, Option<string> tagDisplayType = default, Option<string> hydrusClientAPIAccessKey = default, Option<string> hydrusClientAPISessionKey = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AddTagsSearchTagsAsync(search, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey, tagDisplayType, hydrusClientAPIAccessKey, hydrusClientAPISessionKey, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search the client for tags. Search the client for tags based on the provided query and optional file/tag domain filters.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="search">The tag text to search for, enter exactly what you would in the client UI.</param>
        /// <param name="fileServiceKey">The file service key to limit the search to specific files. (optional)</param>
        /// <param name="fileServiceKeys">A list of file service keys to limit the search to specific files. (optional)</param>
        /// <param name="deletedFileServiceKey">The file service key to search for files deleted from this domain. (optional)</param>
        /// <param name="deletedFileServiceKeys">A list of file service keys to search for files deleted from specific domains. (optional)</param>
        /// <param name="tagServiceKey">The tag service key to limit the search to specific tags. (optional)</param>
        /// <param name="tagDisplayType">Whether to search raw (&#x60;storage&#x60;) or sibling-processed (&#x60;display&#x60;) tags. (optional)</param>
        /// <param name="hydrusClientAPIAccessKey">Permanent access key for authentication. (optional)</param>
        /// <param name="hydrusClientAPISessionKey">Temporary session key for authentication. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsSearchTagsApiResponse"/>&gt;</returns>
        public async Task<IAddTagsSearchTagsApiResponse> AddTagsSearchTagsAsync(string search, Option<string> fileServiceKey = default, Option<List<string>> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<List<string>> deletedFileServiceKeys = default, Option<string> tagServiceKey = default, Option<string> tagDisplayType = default, Option<string> hydrusClientAPIAccessKey = default, Option<string> hydrusClientAPISessionKey = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAddTagsSearchTags(search, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey, tagDisplayType, hydrusClientAPIAccessKey, hydrusClientAPISessionKey);

                FormatAddTagsSearchTags(ref search, ref fileServiceKey, fileServiceKeys, ref deletedFileServiceKey, deletedFileServiceKeys, ref tagServiceKey, ref tagDisplayType, ref hydrusClientAPIAccessKey, ref hydrusClientAPISessionKey);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/add_tags/search_tags"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/add_tags/search_tags");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["search"] = ClientUtils.ParameterToString(search);

                    if (fileServiceKey.IsSet)
                        parseQueryStringLocalVar["file_service_key"] = ClientUtils.ParameterToString(fileServiceKey.Value);

                    if (fileServiceKeys.IsSet)
                        parseQueryStringLocalVar["file_service_keys"] = ClientUtils.ParameterToString(fileServiceKeys.Value);

                    if (deletedFileServiceKey.IsSet)
                        parseQueryStringLocalVar["deleted_file_service_key"] = ClientUtils.ParameterToString(deletedFileServiceKey.Value);

                    if (deletedFileServiceKeys.IsSet)
                        parseQueryStringLocalVar["deleted_file_service_keys"] = ClientUtils.ParameterToString(deletedFileServiceKeys.Value);

                    if (tagServiceKey.IsSet)
                        parseQueryStringLocalVar["tag_service_key"] = ClientUtils.ParameterToString(tagServiceKey.Value);

                    if (tagDisplayType.IsSet)
                        parseQueryStringLocalVar["tag_display_type"] = ClientUtils.ParameterToString(tagDisplayType.Value);

                    if (hydrusClientAPIAccessKey.IsSet)
                        parseQueryStringLocalVar["Hydrus-Client-API-Access-Key"] = ClientUtils.ParameterToString(hydrusClientAPIAccessKey.Value);

                    if (hydrusClientAPISessionKey.IsSet)
                        parseQueryStringLocalVar["Hydrus-Client-API-Session-Key"] = ClientUtils.ParameterToString(hydrusClientAPISessionKey.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Access-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Session-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<AddTagsSearchTagsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AddTagsSearchTagsApiResponse>();
                        AddTagsSearchTagsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/add_tags/search_tags", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterAddTagsSearchTagsDefaultImplementation(apiResponseLocalVar, search, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey, tagDisplayType, hydrusClientAPIAccessKey, hydrusClientAPISessionKey);

                        Events.ExecuteOnAddTagsSearchTags(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAddTagsSearchTagsDefaultImplementation(e, "/add_tags/search_tags", uriBuilderLocalVar.Path, search, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey, tagDisplayType, hydrusClientAPIAccessKey, hydrusClientAPISessionKey);
                Events.ExecuteOnErrorAddTagsSearchTags(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AddTagsSearchTagsApiResponse"/>
        /// </summary>
        public partial class AddTagsSearchTagsApiResponse : HydrusAPI.NET.Client.ApiResponse, IAddTagsSearchTagsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AddTagsSearchTagsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AddTagsSearchTagsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddTagsSearchTagsApiResponse(ILogger<AddTagsSearchTagsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="AddTagsSearchTagsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddTagsSearchTagsApiResponse(ILogger<AddTagsSearchTagsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public HydrusAPI.NET.Model.AddTagsSearchTags200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<HydrusAPI.NET.Model.AddTagsSearchTags200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out HydrusAPI.NET.Model.AddTagsSearchTags200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 419 CustomHttpStatusCode419
            /// </summary>
            /// <returns></returns>
            public bool IsCustomHttpStatusCode419 => 419 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatAddTagsSetFavouriteTags(AddTagsSetFavouriteTagsRequest addTagsSetFavouriteTagsRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="addTagsSetFavouriteTagsRequest"></param>
        /// <returns></returns>
        private void ValidateAddTagsSetFavouriteTags(AddTagsSetFavouriteTagsRequest addTagsSetFavouriteTagsRequest)
        {
            if (addTagsSetFavouriteTagsRequest == null)
                throw new ArgumentNullException(nameof(addTagsSetFavouriteTagsRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="addTagsSetFavouriteTagsRequest"></param>
        private void AfterAddTagsSetFavouriteTagsDefaultImplementation(IAddTagsSetFavouriteTagsApiResponse apiResponseLocalVar, AddTagsSetFavouriteTagsRequest addTagsSetFavouriteTagsRequest)
        {
            bool suppressDefaultLog = false;
            AfterAddTagsSetFavouriteTags(ref suppressDefaultLog, apiResponseLocalVar, addTagsSetFavouriteTagsRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="addTagsSetFavouriteTagsRequest"></param>
        partial void AfterAddTagsSetFavouriteTags(ref bool suppressDefaultLog, IAddTagsSetFavouriteTagsApiResponse apiResponseLocalVar, AddTagsSetFavouriteTagsRequest addTagsSetFavouriteTagsRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="addTagsSetFavouriteTagsRequest"></param>
        private void OnErrorAddTagsSetFavouriteTagsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, AddTagsSetFavouriteTagsRequest addTagsSetFavouriteTagsRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAddTagsSetFavouriteTags(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, addTagsSetFavouriteTagsRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="addTagsSetFavouriteTagsRequest"></param>
        partial void OnErrorAddTagsSetFavouriteTags(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, AddTagsSetFavouriteTagsRequest addTagsSetFavouriteTagsRequest);

        /// <summary>
        /// Set or modify the client&#39;s favourite tags Edits the client&#39;s list of favourite tags either by setting a new list entirely or modifying the existing list with additions or removals.
        /// </summary>
        /// <param name="addTagsSetFavouriteTagsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsSetFavouriteTagsApiResponse"/>&gt;</returns>
        public async Task<IAddTagsSetFavouriteTagsApiResponse?> AddTagsSetFavouriteTagsOrDefaultAsync(AddTagsSetFavouriteTagsRequest addTagsSetFavouriteTagsRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AddTagsSetFavouriteTagsAsync(addTagsSetFavouriteTagsRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Set or modify the client&#39;s favourite tags Edits the client&#39;s list of favourite tags either by setting a new list entirely or modifying the existing list with additions or removals.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="addTagsSetFavouriteTagsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddTagsSetFavouriteTagsApiResponse"/>&gt;</returns>
        public async Task<IAddTagsSetFavouriteTagsApiResponse> AddTagsSetFavouriteTagsAsync(AddTagsSetFavouriteTagsRequest addTagsSetFavouriteTagsRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAddTagsSetFavouriteTags(addTagsSetFavouriteTagsRequest);

                FormatAddTagsSetFavouriteTags(addTagsSetFavouriteTagsRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/add_tags/set_favourite_tags"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/add_tags/set_favourite_tags");

                    httpRequestMessageLocalVar.Content = (addTagsSetFavouriteTagsRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(addTagsSetFavouriteTagsRequest, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Access-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Session-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<AddTagsSetFavouriteTagsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AddTagsSetFavouriteTagsApiResponse>();
                        AddTagsSetFavouriteTagsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/add_tags/set_favourite_tags", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterAddTagsSetFavouriteTagsDefaultImplementation(apiResponseLocalVar, addTagsSetFavouriteTagsRequest);

                        Events.ExecuteOnAddTagsSetFavouriteTags(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAddTagsSetFavouriteTagsDefaultImplementation(e, "/add_tags/set_favourite_tags", uriBuilderLocalVar.Path, addTagsSetFavouriteTagsRequest);
                Events.ExecuteOnErrorAddTagsSetFavouriteTags(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AddTagsSetFavouriteTagsApiResponse"/>
        /// </summary>
        public partial class AddTagsSetFavouriteTagsApiResponse : HydrusAPI.NET.Client.ApiResponse, IAddTagsSetFavouriteTagsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AddTagsSetFavouriteTagsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AddTagsSetFavouriteTagsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddTagsSetFavouriteTagsApiResponse(ILogger<AddTagsSetFavouriteTagsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="AddTagsSetFavouriteTagsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddTagsSetFavouriteTagsApiResponse(ILogger<AddTagsSetFavouriteTagsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public HydrusAPI.NET.Model.AddTagsSetFavouriteTags200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<HydrusAPI.NET.Model.AddTagsSetFavouriteTags200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out HydrusAPI.NET.Model.AddTagsSetFavouriteTags200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 419 CustomHttpStatusCode419
            /// </summary>
            /// <returns></returns>
            public bool IsCustomHttpStatusCode419 => 419 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
