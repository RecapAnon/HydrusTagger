// <auto-generated>
/*
 * Hydrus Client API
 *
 * API for interacting with the Hydrus Client
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using HydrusAPI.NET.Client;
using HydrusAPI.NET.Model;
using System.Diagnostics.CodeAnalysis;

namespace HydrusAPI.NET.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IManageFileRelationshipsApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        ManageFileRelationshipsApiEvents Events { get; }

        /// <summary>
        /// Get file relationships for specified files.
        /// </summary>
        /// <remarks>
        /// Retrieve the current file relationships (e.g., duplicates, alternates) for one or more files.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileId">A single file ID. (optional)</param>
        /// <param name="fileIds">A JSON-encoded and URL-encoded list of file IDs. (optional)</param>
        /// <param name="hash">A single SHA256 hash. (optional)</param>
        /// <param name="hashes">A JSON-encoded and URL-encoded list of SHA256 hashes. (optional)</param>
        /// <param name="fileServiceKey">Optional file domain (service key) to filter the search. (optional)</param>
        /// <param name="fileServiceKeys">Optional list of file domains (service keys) to filter the search. (optional)</param>
        /// <param name="deletedFileServiceKey">Optional file domain (service key) to search deleted files from. (optional)</param>
        /// <param name="deletedFileServiceKeys">Optional list of file domains (service keys) to search deleted files from. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsGetFileRelationshipsApiResponse"/>&gt;</returns>
        Task<IManageFileRelationshipsGetFileRelationshipsApiResponse> ManageFileRelationshipsGetFileRelationshipsAsync(Option<int?> fileId = default, Option<string> fileIds = default, Option<string> hash = default, Option<string> hashes = default, Option<string> fileServiceKey = default, Option<string> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<string> deletedFileServiceKeys = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get file relationships for specified files.
        /// </summary>
        /// <remarks>
        /// Retrieve the current file relationships (e.g., duplicates, alternates) for one or more files.
        /// </remarks>
        /// <param name="fileId">A single file ID. (optional)</param>
        /// <param name="fileIds">A JSON-encoded and URL-encoded list of file IDs. (optional)</param>
        /// <param name="hash">A single SHA256 hash. (optional)</param>
        /// <param name="hashes">A JSON-encoded and URL-encoded list of SHA256 hashes. (optional)</param>
        /// <param name="fileServiceKey">Optional file domain (service key) to filter the search. (optional)</param>
        /// <param name="fileServiceKeys">Optional list of file domains (service keys) to filter the search. (optional)</param>
        /// <param name="deletedFileServiceKey">Optional file domain (service key) to search deleted files from. (optional)</param>
        /// <param name="deletedFileServiceKeys">Optional list of file domains (service keys) to search deleted files from. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsGetFileRelationshipsApiResponse"/>?&gt;</returns>
        Task<IManageFileRelationshipsGetFileRelationshipsApiResponse?> ManageFileRelationshipsGetFileRelationshipsOrDefaultAsync(Option<int?> fileId = default, Option<string> fileIds = default, Option<string> hash = default, Option<string> hashes = default, Option<string> fileServiceKey = default, Option<string> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<string> deletedFileServiceKeys = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get potential duplicate pairs for processing
        /// </summary>
        /// <remarks>
        /// Retrieve a batch of potential duplicate file pairs based on search criteria, similar to the duplicate filter in the client&#39;s duplicate processing page.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileServiceKey"> (optional)</param>
        /// <param name="fileServiceKeys"> (optional)</param>
        /// <param name="deletedFileServiceKey"> (optional)</param>
        /// <param name="deletedFileServiceKeys"> (optional)</param>
        /// <param name="tagServiceKey1"> (optional)</param>
        /// <param name="tags1"> (optional)</param>
        /// <param name="tagServiceKey2"> (optional)</param>
        /// <param name="tags2"> (optional)</param>
        /// <param name="potentialsSearchType"> (optional)</param>
        /// <param name="pixelDuplicates"> (optional)</param>
        /// <param name="maxHammingDistance"> (optional, default to 4)</param>
        /// <param name="maxNumPairs"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsGetPotentialPairsApiResponse"/>&gt;</returns>
        Task<IManageFileRelationshipsGetPotentialPairsApiResponse> ManageFileRelationshipsGetPotentialPairsAsync(Option<string> fileServiceKey = default, Option<List<string>> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<List<string>> deletedFileServiceKeys = default, Option<string> tagServiceKey1 = default, Option<List<string>> tags1 = default, Option<string> tagServiceKey2 = default, Option<List<string>> tags2 = default, Option<int> potentialsSearchType = default, Option<int> pixelDuplicates = default, Option<int> maxHammingDistance = default, Option<int> maxNumPairs = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get potential duplicate pairs for processing
        /// </summary>
        /// <remarks>
        /// Retrieve a batch of potential duplicate file pairs based on search criteria, similar to the duplicate filter in the client&#39;s duplicate processing page.
        /// </remarks>
        /// <param name="fileServiceKey"> (optional)</param>
        /// <param name="fileServiceKeys"> (optional)</param>
        /// <param name="deletedFileServiceKey"> (optional)</param>
        /// <param name="deletedFileServiceKeys"> (optional)</param>
        /// <param name="tagServiceKey1"> (optional)</param>
        /// <param name="tags1"> (optional)</param>
        /// <param name="tagServiceKey2"> (optional)</param>
        /// <param name="tags2"> (optional)</param>
        /// <param name="potentialsSearchType"> (optional)</param>
        /// <param name="pixelDuplicates"> (optional)</param>
        /// <param name="maxHammingDistance"> (optional, default to 4)</param>
        /// <param name="maxNumPairs"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsGetPotentialPairsApiResponse"/>?&gt;</returns>
        Task<IManageFileRelationshipsGetPotentialPairsApiResponse?> ManageFileRelationshipsGetPotentialPairsOrDefaultAsync(Option<string> fileServiceKey = default, Option<List<string>> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<List<string>> deletedFileServiceKeys = default, Option<string> tagServiceKey1 = default, Option<List<string>> tags1 = default, Option<string> tagServiceKey2 = default, Option<List<string>> tags2 = default, Option<int> potentialsSearchType = default, Option<int> pixelDuplicates = default, Option<int> maxHammingDistance = default, Option<int> maxNumPairs = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get the count of potential duplicate file pairs
        /// </summary>
        /// <remarks>
        /// Returns the count of remaining potential duplicate pairs in a specified search domain, based on given filters and search type.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileServiceKey">Hexadecimal service key for a file domain to search. (optional)</param>
        /// <param name="fileServiceKeys">List of hexadecimal service keys for a union of file domains to search. (optional)</param>
        /// <param name="deletedFileServiceKey">Hexadecimal service key for a file domain to search deleted files. (optional)</param>
        /// <param name="deletedFileServiceKeys">List of hexadecimal service keys for a union of file domains to search deleted files. (optional)</param>
        /// <param name="tagServiceKey1">Optional, defaults to &#39;all known tags&#39;. Hexadecimal tag service key. (optional)</param>
        /// <param name="tags1">Optional, defaults to [&#39;system:everything&#39;]. List of tags to filter the first side of pairs. (optional)</param>
        /// <param name="tagServiceKey2">Optional, defaults to &#39;all known tags&#39;. Hexadecimal tag service key for second tag filter. (optional)</param>
        /// <param name="tags2">Optional, defaults to [&#39;system:everything&#39;]. List of tags to filter the second side of pairs. (optional)</param>
        /// <param name="potentialsSearchType">Optional, integer. How the pairs should match the search(es). Default is 0. (optional)</param>
        /// <param name="pixelDuplicates">Optional, integer. Whether pairs should be pixel duplicates. Default is 1. (optional)</param>
        /// <param name="maxHammingDistance">Optional, integer. Max &#39;search distance&#39; of the pairs. Default is 4. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsGetPotentialsCountApiResponse"/>&gt;</returns>
        Task<IManageFileRelationshipsGetPotentialsCountApiResponse> ManageFileRelationshipsGetPotentialsCountAsync(Option<string> fileServiceKey = default, Option<List<string>> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<List<string>> deletedFileServiceKeys = default, Option<string> tagServiceKey1 = default, Option<List<string>> tags1 = default, Option<string> tagServiceKey2 = default, Option<List<string>> tags2 = default, Option<int> potentialsSearchType = default, Option<int> pixelDuplicates = default, Option<int> maxHammingDistance = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get the count of potential duplicate file pairs
        /// </summary>
        /// <remarks>
        /// Returns the count of remaining potential duplicate pairs in a specified search domain, based on given filters and search type.
        /// </remarks>
        /// <param name="fileServiceKey">Hexadecimal service key for a file domain to search. (optional)</param>
        /// <param name="fileServiceKeys">List of hexadecimal service keys for a union of file domains to search. (optional)</param>
        /// <param name="deletedFileServiceKey">Hexadecimal service key for a file domain to search deleted files. (optional)</param>
        /// <param name="deletedFileServiceKeys">List of hexadecimal service keys for a union of file domains to search deleted files. (optional)</param>
        /// <param name="tagServiceKey1">Optional, defaults to &#39;all known tags&#39;. Hexadecimal tag service key. (optional)</param>
        /// <param name="tags1">Optional, defaults to [&#39;system:everything&#39;]. List of tags to filter the first side of pairs. (optional)</param>
        /// <param name="tagServiceKey2">Optional, defaults to &#39;all known tags&#39;. Hexadecimal tag service key for second tag filter. (optional)</param>
        /// <param name="tags2">Optional, defaults to [&#39;system:everything&#39;]. List of tags to filter the second side of pairs. (optional)</param>
        /// <param name="potentialsSearchType">Optional, integer. How the pairs should match the search(es). Default is 0. (optional)</param>
        /// <param name="pixelDuplicates">Optional, integer. Whether pairs should be pixel duplicates. Default is 1. (optional)</param>
        /// <param name="maxHammingDistance">Optional, integer. Max &#39;search distance&#39; of the pairs. Default is 4. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsGetPotentialsCountApiResponse"/>?&gt;</returns>
        Task<IManageFileRelationshipsGetPotentialsCountApiResponse?> ManageFileRelationshipsGetPotentialsCountOrDefaultAsync(Option<string> fileServiceKey = default, Option<List<string>> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<List<string>> deletedFileServiceKeys = default, Option<string> tagServiceKey1 = default, Option<List<string>> tags1 = default, Option<string> tagServiceKey2 = default, Option<List<string>> tags2 = default, Option<int> potentialsSearchType = default, Option<int> pixelDuplicates = default, Option<int> maxHammingDistance = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get some random potentially duplicate file hashes.
        /// </summary>
        /// <remarks>
        /// Exactly the same as the &#39;show some random potential dupes&#39; button in the duplicate processing page.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileServiceKey"> (optional)</param>
        /// <param name="fileServiceKeys"> (optional)</param>
        /// <param name="deletedFileServiceKey"> (optional)</param>
        /// <param name="deletedFileServiceKeys"> (optional)</param>
        /// <param name="tagServiceKey1"> (optional)</param>
        /// <param name="tags1"> (optional)</param>
        /// <param name="tagServiceKey2"> (optional)</param>
        /// <param name="tags2"> (optional)</param>
        /// <param name="potentialsSearchType"> (optional)</param>
        /// <param name="pixelDuplicates"> (optional)</param>
        /// <param name="maxHammingDistance"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsGetRandomPotentialsApiResponse"/>&gt;</returns>
        Task<IManageFileRelationshipsGetRandomPotentialsApiResponse> ManageFileRelationshipsGetRandomPotentialsAsync(Option<string> fileServiceKey = default, Option<List<string>> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<List<string>> deletedFileServiceKeys = default, Option<string> tagServiceKey1 = default, Option<List<string>> tags1 = default, Option<string> tagServiceKey2 = default, Option<List<string>> tags2 = default, Option<int> potentialsSearchType = default, Option<int> pixelDuplicates = default, Option<int?> maxHammingDistance = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get some random potentially duplicate file hashes.
        /// </summary>
        /// <remarks>
        /// Exactly the same as the &#39;show some random potential dupes&#39; button in the duplicate processing page.
        /// </remarks>
        /// <param name="fileServiceKey"> (optional)</param>
        /// <param name="fileServiceKeys"> (optional)</param>
        /// <param name="deletedFileServiceKey"> (optional)</param>
        /// <param name="deletedFileServiceKeys"> (optional)</param>
        /// <param name="tagServiceKey1"> (optional)</param>
        /// <param name="tags1"> (optional)</param>
        /// <param name="tagServiceKey2"> (optional)</param>
        /// <param name="tags2"> (optional)</param>
        /// <param name="potentialsSearchType"> (optional)</param>
        /// <param name="pixelDuplicates"> (optional)</param>
        /// <param name="maxHammingDistance"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsGetRandomPotentialsApiResponse"/>?&gt;</returns>
        Task<IManageFileRelationshipsGetRandomPotentialsApiResponse?> ManageFileRelationshipsGetRandomPotentialsOrDefaultAsync(Option<string> fileServiceKey = default, Option<List<string>> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<List<string>> deletedFileServiceKeys = default, Option<string> tagServiceKey1 = default, Option<List<string>> tags1 = default, Option<string> tagServiceKey2 = default, Option<List<string>> tags2 = default, Option<int> potentialsSearchType = default, Option<int> pixelDuplicates = default, Option<int?> maxHammingDistance = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Remove all potential file relationships for specified files
        /// </summary>
        /// <remarks>
        /// Removes all potential pairs that any of the specified files are a part of. This operation ensures that the files will no longer appear as part of any potential relationships.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="files"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsRemovePotentialsApiResponse"/>&gt;</returns>
        Task<IManageFileRelationshipsRemovePotentialsApiResponse> ManageFileRelationshipsRemovePotentialsAsync(Files? files = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Remove all potential file relationships for specified files
        /// </summary>
        /// <remarks>
        /// Removes all potential pairs that any of the specified files are a part of. This operation ensures that the files will no longer appear as part of any potential relationships.
        /// </remarks>
        /// <param name="files"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsRemovePotentialsApiResponse"/>?&gt;</returns>
        Task<IManageFileRelationshipsRemovePotentialsApiResponse?> ManageFileRelationshipsRemovePotentialsOrDefaultAsync(Files? files = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set file relationships
        /// </summary>
        /// <remarks>
        /// Set relationships (e.g., duplicates, alternates, same quality) between pairs of files.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="manageFileRelationshipsSetFileRelationshipsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsSetFileRelationshipsApiResponse"/>&gt;</returns>
        Task<IManageFileRelationshipsSetFileRelationshipsApiResponse> ManageFileRelationshipsSetFileRelationshipsAsync(ManageFileRelationshipsSetFileRelationshipsRequest manageFileRelationshipsSetFileRelationshipsRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set file relationships
        /// </summary>
        /// <remarks>
        /// Set relationships (e.g., duplicates, alternates, same quality) between pairs of files.
        /// </remarks>
        /// <param name="manageFileRelationshipsSetFileRelationshipsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsSetFileRelationshipsApiResponse"/>?&gt;</returns>
        Task<IManageFileRelationshipsSetFileRelationshipsApiResponse?> ManageFileRelationshipsSetFileRelationshipsOrDefaultAsync(ManageFileRelationshipsSetFileRelationshipsRequest manageFileRelationshipsSetFileRelationshipsRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set files as kings of their duplicate groups
        /// </summary>
        /// <remarks>
        /// Promotes the specified files to be the \&quot;king\&quot; of their respective duplicate groups. This operation is idempotent and processes files in the order they are provided.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="manageFileRelationshipsSetKingsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsSetKingsApiResponse"/>&gt;</returns>
        Task<IManageFileRelationshipsSetKingsApiResponse> ManageFileRelationshipsSetKingsAsync(ManageFileRelationshipsSetKingsRequest? manageFileRelationshipsSetKingsRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set files as kings of their duplicate groups
        /// </summary>
        /// <remarks>
        /// Promotes the specified files to be the \&quot;king\&quot; of their respective duplicate groups. This operation is idempotent and processes files in the order they are provided.
        /// </remarks>
        /// <param name="manageFileRelationshipsSetKingsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsSetKingsApiResponse"/>?&gt;</returns>
        Task<IManageFileRelationshipsSetKingsApiResponse?> ManageFileRelationshipsSetKingsOrDefaultAsync(ManageFileRelationshipsSetKingsRequest? manageFileRelationshipsSetKingsRequest = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IManageFileRelationshipsGetFileRelationshipsApiResponse"/>
    /// </summary>
    public interface IManageFileRelationshipsGetFileRelationshipsApiResponse : HydrusAPI.NET.Client.IApiResponse, IOk<HydrusAPI.NET.Model.FileRelationshipsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 419 CustomHttpStatusCode419
        /// </summary>
        /// <returns></returns>
        bool IsCustomHttpStatusCode419 { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IManageFileRelationshipsGetPotentialPairsApiResponse"/>
    /// </summary>
    public interface IManageFileRelationshipsGetPotentialPairsApiResponse : HydrusAPI.NET.Client.IApiResponse, IOk<HydrusAPI.NET.Model.ManageFileRelationshipsGetPotentialPairs200Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 419 CustomHttpStatusCode419
        /// </summary>
        /// <returns></returns>
        bool IsCustomHttpStatusCode419 { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IManageFileRelationshipsGetPotentialsCountApiResponse"/>
    /// </summary>
    public interface IManageFileRelationshipsGetPotentialsCountApiResponse : HydrusAPI.NET.Client.IApiResponse, IOk<HydrusAPI.NET.Model.ManageFileRelationshipsGetPotentialsCount200Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 419 CustomHttpStatusCode419
        /// </summary>
        /// <returns></returns>
        bool IsCustomHttpStatusCode419 { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IManageFileRelationshipsGetRandomPotentialsApiResponse"/>
    /// </summary>
    public interface IManageFileRelationshipsGetRandomPotentialsApiResponse : HydrusAPI.NET.Client.IApiResponse, IOk<HydrusAPI.NET.Model.ManageFileRelationshipsGetRandomPotentials200Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 419 CustomHttpStatusCode419
        /// </summary>
        /// <returns></returns>
        bool IsCustomHttpStatusCode419 { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IManageFileRelationshipsRemovePotentialsApiResponse"/>
    /// </summary>
    public interface IManageFileRelationshipsRemovePotentialsApiResponse : HydrusAPI.NET.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 419 CustomHttpStatusCode419
        /// </summary>
        /// <returns></returns>
        bool IsCustomHttpStatusCode419 { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IManageFileRelationshipsSetFileRelationshipsApiResponse"/>
    /// </summary>
    public interface IManageFileRelationshipsSetFileRelationshipsApiResponse : HydrusAPI.NET.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IManageFileRelationshipsSetKingsApiResponse"/>
    /// </summary>
    public interface IManageFileRelationshipsSetKingsApiResponse : HydrusAPI.NET.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 419 CustomHttpStatusCode419
        /// </summary>
        /// <returns></returns>
        bool IsCustomHttpStatusCode419 { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class ManageFileRelationshipsApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnManageFileRelationshipsGetFileRelationships;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorManageFileRelationshipsGetFileRelationships;

        internal void ExecuteOnManageFileRelationshipsGetFileRelationships(ManageFileRelationshipsApi.ManageFileRelationshipsGetFileRelationshipsApiResponse apiResponse)
        {
            OnManageFileRelationshipsGetFileRelationships?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorManageFileRelationshipsGetFileRelationships(Exception exception)
        {
            OnErrorManageFileRelationshipsGetFileRelationships?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnManageFileRelationshipsGetPotentialPairs;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorManageFileRelationshipsGetPotentialPairs;

        internal void ExecuteOnManageFileRelationshipsGetPotentialPairs(ManageFileRelationshipsApi.ManageFileRelationshipsGetPotentialPairsApiResponse apiResponse)
        {
            OnManageFileRelationshipsGetPotentialPairs?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorManageFileRelationshipsGetPotentialPairs(Exception exception)
        {
            OnErrorManageFileRelationshipsGetPotentialPairs?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnManageFileRelationshipsGetPotentialsCount;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorManageFileRelationshipsGetPotentialsCount;

        internal void ExecuteOnManageFileRelationshipsGetPotentialsCount(ManageFileRelationshipsApi.ManageFileRelationshipsGetPotentialsCountApiResponse apiResponse)
        {
            OnManageFileRelationshipsGetPotentialsCount?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorManageFileRelationshipsGetPotentialsCount(Exception exception)
        {
            OnErrorManageFileRelationshipsGetPotentialsCount?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnManageFileRelationshipsGetRandomPotentials;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorManageFileRelationshipsGetRandomPotentials;

        internal void ExecuteOnManageFileRelationshipsGetRandomPotentials(ManageFileRelationshipsApi.ManageFileRelationshipsGetRandomPotentialsApiResponse apiResponse)
        {
            OnManageFileRelationshipsGetRandomPotentials?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorManageFileRelationshipsGetRandomPotentials(Exception exception)
        {
            OnErrorManageFileRelationshipsGetRandomPotentials?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnManageFileRelationshipsRemovePotentials;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorManageFileRelationshipsRemovePotentials;

        internal void ExecuteOnManageFileRelationshipsRemovePotentials(ManageFileRelationshipsApi.ManageFileRelationshipsRemovePotentialsApiResponse apiResponse)
        {
            OnManageFileRelationshipsRemovePotentials?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorManageFileRelationshipsRemovePotentials(Exception exception)
        {
            OnErrorManageFileRelationshipsRemovePotentials?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnManageFileRelationshipsSetFileRelationships;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorManageFileRelationshipsSetFileRelationships;

        internal void ExecuteOnManageFileRelationshipsSetFileRelationships(ManageFileRelationshipsApi.ManageFileRelationshipsSetFileRelationshipsApiResponse apiResponse)
        {
            OnManageFileRelationshipsSetFileRelationships?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorManageFileRelationshipsSetFileRelationships(Exception exception)
        {
            OnErrorManageFileRelationshipsSetFileRelationships?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnManageFileRelationshipsSetKings;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorManageFileRelationshipsSetKings;

        internal void ExecuteOnManageFileRelationshipsSetKings(ManageFileRelationshipsApi.ManageFileRelationshipsSetKingsApiResponse apiResponse)
        {
            OnManageFileRelationshipsSetKings?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorManageFileRelationshipsSetKings(Exception exception)
        {
            OnErrorManageFileRelationshipsSetKings?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class ManageFileRelationshipsApi : IManageFileRelationshipsApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<ManageFileRelationshipsApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public ManageFileRelationshipsApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ManageFileRelationshipsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ManageFileRelationshipsApi(ILogger<ManageFileRelationshipsApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, ManageFileRelationshipsApiEvents manageFileRelationshipsApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<ManageFileRelationshipsApi>();
            HttpClient = httpClient;
            Events = manageFileRelationshipsApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatManageFileRelationshipsGetFileRelationships(ref Option<int?> fileId, ref Option<string> fileIds, ref Option<string> hash, ref Option<string> hashes, ref Option<string> fileServiceKey, ref Option<string> fileServiceKeys, ref Option<string> deletedFileServiceKey, ref Option<string> deletedFileServiceKeys);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="fileIds"></param>
        /// <param name="hash"></param>
        /// <param name="hashes"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <returns></returns>
        private void ValidateManageFileRelationshipsGetFileRelationships(Option<string> fileIds, Option<string> hash, Option<string> hashes, Option<string> fileServiceKey, Option<string> fileServiceKeys, Option<string> deletedFileServiceKey, Option<string> deletedFileServiceKeys)
        {
            if (fileIds.IsSet && fileIds.Value == null)
                throw new ArgumentNullException(nameof(fileIds));

            if (hash.IsSet && hash.Value == null)
                throw new ArgumentNullException(nameof(hash));

            if (hashes.IsSet && hashes.Value == null)
                throw new ArgumentNullException(nameof(hashes));

            if (fileServiceKey.IsSet && fileServiceKey.Value == null)
                throw new ArgumentNullException(nameof(fileServiceKey));

            if (fileServiceKeys.IsSet && fileServiceKeys.Value == null)
                throw new ArgumentNullException(nameof(fileServiceKeys));

            if (deletedFileServiceKey.IsSet && deletedFileServiceKey.Value == null)
                throw new ArgumentNullException(nameof(deletedFileServiceKey));

            if (deletedFileServiceKeys.IsSet && deletedFileServiceKeys.Value == null)
                throw new ArgumentNullException(nameof(deletedFileServiceKeys));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="fileIds"></param>
        /// <param name="hash"></param>
        /// <param name="hashes"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        private void AfterManageFileRelationshipsGetFileRelationshipsDefaultImplementation(IManageFileRelationshipsGetFileRelationshipsApiResponse apiResponseLocalVar, Option<int?> fileId, Option<string> fileIds, Option<string> hash, Option<string> hashes, Option<string> fileServiceKey, Option<string> fileServiceKeys, Option<string> deletedFileServiceKey, Option<string> deletedFileServiceKeys)
        {
            bool suppressDefaultLog = false;
            AfterManageFileRelationshipsGetFileRelationships(ref suppressDefaultLog, apiResponseLocalVar, fileId, fileIds, hash, hashes, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="fileIds"></param>
        /// <param name="hash"></param>
        /// <param name="hashes"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        partial void AfterManageFileRelationshipsGetFileRelationships(ref bool suppressDefaultLog, IManageFileRelationshipsGetFileRelationshipsApiResponse apiResponseLocalVar, Option<int?> fileId, Option<string> fileIds, Option<string> hash, Option<string> hashes, Option<string> fileServiceKey, Option<string> fileServiceKeys, Option<string> deletedFileServiceKey, Option<string> deletedFileServiceKeys);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="fileIds"></param>
        /// <param name="hash"></param>
        /// <param name="hashes"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        private void OnErrorManageFileRelationshipsGetFileRelationshipsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int?> fileId, Option<string> fileIds, Option<string> hash, Option<string> hashes, Option<string> fileServiceKey, Option<string> fileServiceKeys, Option<string> deletedFileServiceKey, Option<string> deletedFileServiceKeys)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorManageFileRelationshipsGetFileRelationships(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, fileId, fileIds, hash, hashes, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="fileIds"></param>
        /// <param name="hash"></param>
        /// <param name="hashes"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        partial void OnErrorManageFileRelationshipsGetFileRelationships(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int?> fileId, Option<string> fileIds, Option<string> hash, Option<string> hashes, Option<string> fileServiceKey, Option<string> fileServiceKeys, Option<string> deletedFileServiceKey, Option<string> deletedFileServiceKeys);

        /// <summary>
        /// Get file relationships for specified files. Retrieve the current file relationships (e.g., duplicates, alternates) for one or more files.
        /// </summary>
        /// <param name="fileId">A single file ID. (optional)</param>
        /// <param name="fileIds">A JSON-encoded and URL-encoded list of file IDs. (optional)</param>
        /// <param name="hash">A single SHA256 hash. (optional)</param>
        /// <param name="hashes">A JSON-encoded and URL-encoded list of SHA256 hashes. (optional)</param>
        /// <param name="fileServiceKey">Optional file domain (service key) to filter the search. (optional)</param>
        /// <param name="fileServiceKeys">Optional list of file domains (service keys) to filter the search. (optional)</param>
        /// <param name="deletedFileServiceKey">Optional file domain (service key) to search deleted files from. (optional)</param>
        /// <param name="deletedFileServiceKeys">Optional list of file domains (service keys) to search deleted files from. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsGetFileRelationshipsApiResponse"/>&gt;</returns>
        public async Task<IManageFileRelationshipsGetFileRelationshipsApiResponse?> ManageFileRelationshipsGetFileRelationshipsOrDefaultAsync(Option<int?> fileId = default, Option<string> fileIds = default, Option<string> hash = default, Option<string> hashes = default, Option<string> fileServiceKey = default, Option<string> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<string> deletedFileServiceKeys = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ManageFileRelationshipsGetFileRelationshipsAsync(fileId, fileIds, hash, hashes, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get file relationships for specified files. Retrieve the current file relationships (e.g., duplicates, alternates) for one or more files.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileId">A single file ID. (optional)</param>
        /// <param name="fileIds">A JSON-encoded and URL-encoded list of file IDs. (optional)</param>
        /// <param name="hash">A single SHA256 hash. (optional)</param>
        /// <param name="hashes">A JSON-encoded and URL-encoded list of SHA256 hashes. (optional)</param>
        /// <param name="fileServiceKey">Optional file domain (service key) to filter the search. (optional)</param>
        /// <param name="fileServiceKeys">Optional list of file domains (service keys) to filter the search. (optional)</param>
        /// <param name="deletedFileServiceKey">Optional file domain (service key) to search deleted files from. (optional)</param>
        /// <param name="deletedFileServiceKeys">Optional list of file domains (service keys) to search deleted files from. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsGetFileRelationshipsApiResponse"/>&gt;</returns>
        public async Task<IManageFileRelationshipsGetFileRelationshipsApiResponse> ManageFileRelationshipsGetFileRelationshipsAsync(Option<int?> fileId = default, Option<string> fileIds = default, Option<string> hash = default, Option<string> hashes = default, Option<string> fileServiceKey = default, Option<string> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<string> deletedFileServiceKeys = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateManageFileRelationshipsGetFileRelationships(fileIds, hash, hashes, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys);

                FormatManageFileRelationshipsGetFileRelationships(ref fileId, ref fileIds, ref hash, ref hashes, ref fileServiceKey, ref fileServiceKeys, ref deletedFileServiceKey, ref deletedFileServiceKeys);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/manage_file_relationships/get_file_relationships"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/manage_file_relationships/get_file_relationships");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (fileId.IsSet)
                        parseQueryStringLocalVar["file_id"] = ClientUtils.ParameterToString(fileId.Value);

                    if (fileIds.IsSet)
                        parseQueryStringLocalVar["file_ids"] = ClientUtils.ParameterToString(fileIds.Value);

                    if (hash.IsSet)
                        parseQueryStringLocalVar["hash"] = ClientUtils.ParameterToString(hash.Value);

                    if (hashes.IsSet)
                        parseQueryStringLocalVar["hashes"] = ClientUtils.ParameterToString(hashes.Value);

                    if (fileServiceKey.IsSet)
                        parseQueryStringLocalVar["file_service_key"] = ClientUtils.ParameterToString(fileServiceKey.Value);

                    if (fileServiceKeys.IsSet)
                        parseQueryStringLocalVar["file_service_keys"] = ClientUtils.ParameterToString(fileServiceKeys.Value);

                    if (deletedFileServiceKey.IsSet)
                        parseQueryStringLocalVar["deleted_file_service_key"] = ClientUtils.ParameterToString(deletedFileServiceKey.Value);

                    if (deletedFileServiceKeys.IsSet)
                        parseQueryStringLocalVar["deleted_file_service_keys"] = ClientUtils.ParameterToString(deletedFileServiceKeys.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Access-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Session-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ManageFileRelationshipsGetFileRelationshipsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ManageFileRelationshipsGetFileRelationshipsApiResponse>();

                        ManageFileRelationshipsGetFileRelationshipsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/manage_file_relationships/get_file_relationships", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterManageFileRelationshipsGetFileRelationshipsDefaultImplementation(apiResponseLocalVar, fileId, fileIds, hash, hashes, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys);

                        Events.ExecuteOnManageFileRelationshipsGetFileRelationships(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorManageFileRelationshipsGetFileRelationshipsDefaultImplementation(e, "/manage_file_relationships/get_file_relationships", uriBuilderLocalVar.Path, fileId, fileIds, hash, hashes, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys);
                Events.ExecuteOnErrorManageFileRelationshipsGetFileRelationships(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ManageFileRelationshipsGetFileRelationshipsApiResponse"/>
        /// </summary>
        public partial class ManageFileRelationshipsGetFileRelationshipsApiResponse : HydrusAPI.NET.Client.ApiResponse, IManageFileRelationshipsGetFileRelationshipsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ManageFileRelationshipsGetFileRelationshipsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ManageFileRelationshipsGetFileRelationshipsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ManageFileRelationshipsGetFileRelationshipsApiResponse(ILogger<ManageFileRelationshipsGetFileRelationshipsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public HydrusAPI.NET.Model.FileRelationshipsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<HydrusAPI.NET.Model.FileRelationshipsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out HydrusAPI.NET.Model.FileRelationshipsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 419 CustomHttpStatusCode419
            /// </summary>
            /// <returns></returns>
            public bool IsCustomHttpStatusCode419 => 419 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatManageFileRelationshipsGetPotentialPairs(ref Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, ref Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, ref Option<string> tagServiceKey1, Option<List<string>> tags1, ref Option<string> tagServiceKey2, Option<List<string>> tags2, ref Option<int> potentialsSearchType, ref Option<int> pixelDuplicates, ref Option<int> maxHammingDistance, ref Option<int> maxNumPairs);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey1"></param>
        /// <param name="tags1"></param>
        /// <param name="tagServiceKey2"></param>
        /// <param name="tags2"></param>
        /// <returns></returns>
        private void ValidateManageFileRelationshipsGetPotentialPairs(Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey1, Option<List<string>> tags1, Option<string> tagServiceKey2, Option<List<string>> tags2)
        {
            if (fileServiceKey.IsSet && fileServiceKey.Value == null)
                throw new ArgumentNullException(nameof(fileServiceKey));

            if (fileServiceKeys.IsSet && fileServiceKeys.Value == null)
                throw new ArgumentNullException(nameof(fileServiceKeys));

            if (deletedFileServiceKey.IsSet && deletedFileServiceKey.Value == null)
                throw new ArgumentNullException(nameof(deletedFileServiceKey));

            if (deletedFileServiceKeys.IsSet && deletedFileServiceKeys.Value == null)
                throw new ArgumentNullException(nameof(deletedFileServiceKeys));

            if (tagServiceKey1.IsSet && tagServiceKey1.Value == null)
                throw new ArgumentNullException(nameof(tagServiceKey1));

            if (tags1.IsSet && tags1.Value == null)
                throw new ArgumentNullException(nameof(tags1));

            if (tagServiceKey2.IsSet && tagServiceKey2.Value == null)
                throw new ArgumentNullException(nameof(tagServiceKey2));

            if (tags2.IsSet && tags2.Value == null)
                throw new ArgumentNullException(nameof(tags2));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey1"></param>
        /// <param name="tags1"></param>
        /// <param name="tagServiceKey2"></param>
        /// <param name="tags2"></param>
        /// <param name="potentialsSearchType"></param>
        /// <param name="pixelDuplicates"></param>
        /// <param name="maxHammingDistance"></param>
        /// <param name="maxNumPairs"></param>
        private void AfterManageFileRelationshipsGetPotentialPairsDefaultImplementation(IManageFileRelationshipsGetPotentialPairsApiResponse apiResponseLocalVar, Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey1, Option<List<string>> tags1, Option<string> tagServiceKey2, Option<List<string>> tags2, Option<int> potentialsSearchType, Option<int> pixelDuplicates, Option<int> maxHammingDistance, Option<int> maxNumPairs)
        {
            bool suppressDefaultLog = false;
            AfterManageFileRelationshipsGetPotentialPairs(ref suppressDefaultLog, apiResponseLocalVar, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey1, tags1, tagServiceKey2, tags2, potentialsSearchType, pixelDuplicates, maxHammingDistance, maxNumPairs);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey1"></param>
        /// <param name="tags1"></param>
        /// <param name="tagServiceKey2"></param>
        /// <param name="tags2"></param>
        /// <param name="potentialsSearchType"></param>
        /// <param name="pixelDuplicates"></param>
        /// <param name="maxHammingDistance"></param>
        /// <param name="maxNumPairs"></param>
        partial void AfterManageFileRelationshipsGetPotentialPairs(ref bool suppressDefaultLog, IManageFileRelationshipsGetPotentialPairsApiResponse apiResponseLocalVar, Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey1, Option<List<string>> tags1, Option<string> tagServiceKey2, Option<List<string>> tags2, Option<int> potentialsSearchType, Option<int> pixelDuplicates, Option<int> maxHammingDistance, Option<int> maxNumPairs);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey1"></param>
        /// <param name="tags1"></param>
        /// <param name="tagServiceKey2"></param>
        /// <param name="tags2"></param>
        /// <param name="potentialsSearchType"></param>
        /// <param name="pixelDuplicates"></param>
        /// <param name="maxHammingDistance"></param>
        /// <param name="maxNumPairs"></param>
        private void OnErrorManageFileRelationshipsGetPotentialPairsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey1, Option<List<string>> tags1, Option<string> tagServiceKey2, Option<List<string>> tags2, Option<int> potentialsSearchType, Option<int> pixelDuplicates, Option<int> maxHammingDistance, Option<int> maxNumPairs)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorManageFileRelationshipsGetPotentialPairs(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey1, tags1, tagServiceKey2, tags2, potentialsSearchType, pixelDuplicates, maxHammingDistance, maxNumPairs);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey1"></param>
        /// <param name="tags1"></param>
        /// <param name="tagServiceKey2"></param>
        /// <param name="tags2"></param>
        /// <param name="potentialsSearchType"></param>
        /// <param name="pixelDuplicates"></param>
        /// <param name="maxHammingDistance"></param>
        /// <param name="maxNumPairs"></param>
        partial void OnErrorManageFileRelationshipsGetPotentialPairs(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey1, Option<List<string>> tags1, Option<string> tagServiceKey2, Option<List<string>> tags2, Option<int> potentialsSearchType, Option<int> pixelDuplicates, Option<int> maxHammingDistance, Option<int> maxNumPairs);

        /// <summary>
        /// Get potential duplicate pairs for processing Retrieve a batch of potential duplicate file pairs based on search criteria, similar to the duplicate filter in the client&#39;s duplicate processing page.
        /// </summary>
        /// <param name="fileServiceKey"> (optional)</param>
        /// <param name="fileServiceKeys"> (optional)</param>
        /// <param name="deletedFileServiceKey"> (optional)</param>
        /// <param name="deletedFileServiceKeys"> (optional)</param>
        /// <param name="tagServiceKey1"> (optional)</param>
        /// <param name="tags1"> (optional)</param>
        /// <param name="tagServiceKey2"> (optional)</param>
        /// <param name="tags2"> (optional)</param>
        /// <param name="potentialsSearchType"> (optional)</param>
        /// <param name="pixelDuplicates"> (optional)</param>
        /// <param name="maxHammingDistance"> (optional, default to 4)</param>
        /// <param name="maxNumPairs"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsGetPotentialPairsApiResponse"/>&gt;</returns>
        public async Task<IManageFileRelationshipsGetPotentialPairsApiResponse?> ManageFileRelationshipsGetPotentialPairsOrDefaultAsync(Option<string> fileServiceKey = default, Option<List<string>> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<List<string>> deletedFileServiceKeys = default, Option<string> tagServiceKey1 = default, Option<List<string>> tags1 = default, Option<string> tagServiceKey2 = default, Option<List<string>> tags2 = default, Option<int> potentialsSearchType = default, Option<int> pixelDuplicates = default, Option<int> maxHammingDistance = default, Option<int> maxNumPairs = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ManageFileRelationshipsGetPotentialPairsAsync(fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey1, tags1, tagServiceKey2, tags2, potentialsSearchType, pixelDuplicates, maxHammingDistance, maxNumPairs, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get potential duplicate pairs for processing Retrieve a batch of potential duplicate file pairs based on search criteria, similar to the duplicate filter in the client&#39;s duplicate processing page.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileServiceKey"> (optional)</param>
        /// <param name="fileServiceKeys"> (optional)</param>
        /// <param name="deletedFileServiceKey"> (optional)</param>
        /// <param name="deletedFileServiceKeys"> (optional)</param>
        /// <param name="tagServiceKey1"> (optional)</param>
        /// <param name="tags1"> (optional)</param>
        /// <param name="tagServiceKey2"> (optional)</param>
        /// <param name="tags2"> (optional)</param>
        /// <param name="potentialsSearchType"> (optional)</param>
        /// <param name="pixelDuplicates"> (optional)</param>
        /// <param name="maxHammingDistance"> (optional, default to 4)</param>
        /// <param name="maxNumPairs"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsGetPotentialPairsApiResponse"/>&gt;</returns>
        public async Task<IManageFileRelationshipsGetPotentialPairsApiResponse> ManageFileRelationshipsGetPotentialPairsAsync(Option<string> fileServiceKey = default, Option<List<string>> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<List<string>> deletedFileServiceKeys = default, Option<string> tagServiceKey1 = default, Option<List<string>> tags1 = default, Option<string> tagServiceKey2 = default, Option<List<string>> tags2 = default, Option<int> potentialsSearchType = default, Option<int> pixelDuplicates = default, Option<int> maxHammingDistance = default, Option<int> maxNumPairs = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateManageFileRelationshipsGetPotentialPairs(fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey1, tags1, tagServiceKey2, tags2);

                FormatManageFileRelationshipsGetPotentialPairs(ref fileServiceKey, fileServiceKeys, ref deletedFileServiceKey, deletedFileServiceKeys, ref tagServiceKey1, tags1, ref tagServiceKey2, tags2, ref potentialsSearchType, ref pixelDuplicates, ref maxHammingDistance, ref maxNumPairs);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/manage_file_relationships/get_potential_pairs"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/manage_file_relationships/get_potential_pairs");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (fileServiceKey.IsSet)
                        parseQueryStringLocalVar["file_service_key"] = ClientUtils.ParameterToString(fileServiceKey.Value);

                    if (fileServiceKeys.IsSet)
                        parseQueryStringLocalVar["file_service_keys"] = ClientUtils.ParameterToString(fileServiceKeys.Value);

                    if (deletedFileServiceKey.IsSet)
                        parseQueryStringLocalVar["deleted_file_service_key"] = ClientUtils.ParameterToString(deletedFileServiceKey.Value);

                    if (deletedFileServiceKeys.IsSet)
                        parseQueryStringLocalVar["deleted_file_service_keys"] = ClientUtils.ParameterToString(deletedFileServiceKeys.Value);

                    if (tagServiceKey1.IsSet)
                        parseQueryStringLocalVar["tag_service_key_1"] = ClientUtils.ParameterToString(tagServiceKey1.Value);

                    if (tags1.IsSet)
                        parseQueryStringLocalVar["tags_1"] = ClientUtils.ParameterToString(tags1.Value);

                    if (tagServiceKey2.IsSet)
                        parseQueryStringLocalVar["tag_service_key_2"] = ClientUtils.ParameterToString(tagServiceKey2.Value);

                    if (tags2.IsSet)
                        parseQueryStringLocalVar["tags_2"] = ClientUtils.ParameterToString(tags2.Value);

                    if (potentialsSearchType.IsSet)
                        parseQueryStringLocalVar["potentials_search_type"] = ClientUtils.ParameterToString(potentialsSearchType.Value);

                    if (pixelDuplicates.IsSet)
                        parseQueryStringLocalVar["pixel_duplicates"] = ClientUtils.ParameterToString(pixelDuplicates.Value);

                    if (maxHammingDistance.IsSet)
                        parseQueryStringLocalVar["max_hamming_distance"] = ClientUtils.ParameterToString(maxHammingDistance.Value);

                    if (maxNumPairs.IsSet)
                        parseQueryStringLocalVar["max_num_pairs"] = ClientUtils.ParameterToString(maxNumPairs.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Access-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Session-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ManageFileRelationshipsGetPotentialPairsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ManageFileRelationshipsGetPotentialPairsApiResponse>();

                        ManageFileRelationshipsGetPotentialPairsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/manage_file_relationships/get_potential_pairs", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterManageFileRelationshipsGetPotentialPairsDefaultImplementation(apiResponseLocalVar, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey1, tags1, tagServiceKey2, tags2, potentialsSearchType, pixelDuplicates, maxHammingDistance, maxNumPairs);

                        Events.ExecuteOnManageFileRelationshipsGetPotentialPairs(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorManageFileRelationshipsGetPotentialPairsDefaultImplementation(e, "/manage_file_relationships/get_potential_pairs", uriBuilderLocalVar.Path, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey1, tags1, tagServiceKey2, tags2, potentialsSearchType, pixelDuplicates, maxHammingDistance, maxNumPairs);
                Events.ExecuteOnErrorManageFileRelationshipsGetPotentialPairs(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ManageFileRelationshipsGetPotentialPairsApiResponse"/>
        /// </summary>
        public partial class ManageFileRelationshipsGetPotentialPairsApiResponse : HydrusAPI.NET.Client.ApiResponse, IManageFileRelationshipsGetPotentialPairsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ManageFileRelationshipsGetPotentialPairsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ManageFileRelationshipsGetPotentialPairsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ManageFileRelationshipsGetPotentialPairsApiResponse(ILogger<ManageFileRelationshipsGetPotentialPairsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public HydrusAPI.NET.Model.ManageFileRelationshipsGetPotentialPairs200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<HydrusAPI.NET.Model.ManageFileRelationshipsGetPotentialPairs200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out HydrusAPI.NET.Model.ManageFileRelationshipsGetPotentialPairs200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 419 CustomHttpStatusCode419
            /// </summary>
            /// <returns></returns>
            public bool IsCustomHttpStatusCode419 => 419 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatManageFileRelationshipsGetPotentialsCount(ref Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, ref Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, ref Option<string> tagServiceKey1, Option<List<string>> tags1, ref Option<string> tagServiceKey2, Option<List<string>> tags2, ref Option<int> potentialsSearchType, ref Option<int> pixelDuplicates, ref Option<int> maxHammingDistance);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey1"></param>
        /// <param name="tags1"></param>
        /// <param name="tagServiceKey2"></param>
        /// <param name="tags2"></param>
        /// <returns></returns>
        private void ValidateManageFileRelationshipsGetPotentialsCount(Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey1, Option<List<string>> tags1, Option<string> tagServiceKey2, Option<List<string>> tags2)
        {
            if (fileServiceKey.IsSet && fileServiceKey.Value == null)
                throw new ArgumentNullException(nameof(fileServiceKey));

            if (fileServiceKeys.IsSet && fileServiceKeys.Value == null)
                throw new ArgumentNullException(nameof(fileServiceKeys));

            if (deletedFileServiceKey.IsSet && deletedFileServiceKey.Value == null)
                throw new ArgumentNullException(nameof(deletedFileServiceKey));

            if (deletedFileServiceKeys.IsSet && deletedFileServiceKeys.Value == null)
                throw new ArgumentNullException(nameof(deletedFileServiceKeys));

            if (tagServiceKey1.IsSet && tagServiceKey1.Value == null)
                throw new ArgumentNullException(nameof(tagServiceKey1));

            if (tags1.IsSet && tags1.Value == null)
                throw new ArgumentNullException(nameof(tags1));

            if (tagServiceKey2.IsSet && tagServiceKey2.Value == null)
                throw new ArgumentNullException(nameof(tagServiceKey2));

            if (tags2.IsSet && tags2.Value == null)
                throw new ArgumentNullException(nameof(tags2));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey1"></param>
        /// <param name="tags1"></param>
        /// <param name="tagServiceKey2"></param>
        /// <param name="tags2"></param>
        /// <param name="potentialsSearchType"></param>
        /// <param name="pixelDuplicates"></param>
        /// <param name="maxHammingDistance"></param>
        private void AfterManageFileRelationshipsGetPotentialsCountDefaultImplementation(IManageFileRelationshipsGetPotentialsCountApiResponse apiResponseLocalVar, Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey1, Option<List<string>> tags1, Option<string> tagServiceKey2, Option<List<string>> tags2, Option<int> potentialsSearchType, Option<int> pixelDuplicates, Option<int> maxHammingDistance)
        {
            bool suppressDefaultLog = false;
            AfterManageFileRelationshipsGetPotentialsCount(ref suppressDefaultLog, apiResponseLocalVar, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey1, tags1, tagServiceKey2, tags2, potentialsSearchType, pixelDuplicates, maxHammingDistance);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey1"></param>
        /// <param name="tags1"></param>
        /// <param name="tagServiceKey2"></param>
        /// <param name="tags2"></param>
        /// <param name="potentialsSearchType"></param>
        /// <param name="pixelDuplicates"></param>
        /// <param name="maxHammingDistance"></param>
        partial void AfterManageFileRelationshipsGetPotentialsCount(ref bool suppressDefaultLog, IManageFileRelationshipsGetPotentialsCountApiResponse apiResponseLocalVar, Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey1, Option<List<string>> tags1, Option<string> tagServiceKey2, Option<List<string>> tags2, Option<int> potentialsSearchType, Option<int> pixelDuplicates, Option<int> maxHammingDistance);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey1"></param>
        /// <param name="tags1"></param>
        /// <param name="tagServiceKey2"></param>
        /// <param name="tags2"></param>
        /// <param name="potentialsSearchType"></param>
        /// <param name="pixelDuplicates"></param>
        /// <param name="maxHammingDistance"></param>
        private void OnErrorManageFileRelationshipsGetPotentialsCountDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey1, Option<List<string>> tags1, Option<string> tagServiceKey2, Option<List<string>> tags2, Option<int> potentialsSearchType, Option<int> pixelDuplicates, Option<int> maxHammingDistance)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorManageFileRelationshipsGetPotentialsCount(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey1, tags1, tagServiceKey2, tags2, potentialsSearchType, pixelDuplicates, maxHammingDistance);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey1"></param>
        /// <param name="tags1"></param>
        /// <param name="tagServiceKey2"></param>
        /// <param name="tags2"></param>
        /// <param name="potentialsSearchType"></param>
        /// <param name="pixelDuplicates"></param>
        /// <param name="maxHammingDistance"></param>
        partial void OnErrorManageFileRelationshipsGetPotentialsCount(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey1, Option<List<string>> tags1, Option<string> tagServiceKey2, Option<List<string>> tags2, Option<int> potentialsSearchType, Option<int> pixelDuplicates, Option<int> maxHammingDistance);

        /// <summary>
        /// Get the count of potential duplicate file pairs Returns the count of remaining potential duplicate pairs in a specified search domain, based on given filters and search type.
        /// </summary>
        /// <param name="fileServiceKey">Hexadecimal service key for a file domain to search. (optional)</param>
        /// <param name="fileServiceKeys">List of hexadecimal service keys for a union of file domains to search. (optional)</param>
        /// <param name="deletedFileServiceKey">Hexadecimal service key for a file domain to search deleted files. (optional)</param>
        /// <param name="deletedFileServiceKeys">List of hexadecimal service keys for a union of file domains to search deleted files. (optional)</param>
        /// <param name="tagServiceKey1">Optional, defaults to &#39;all known tags&#39;. Hexadecimal tag service key. (optional)</param>
        /// <param name="tags1">Optional, defaults to [&#39;system:everything&#39;]. List of tags to filter the first side of pairs. (optional)</param>
        /// <param name="tagServiceKey2">Optional, defaults to &#39;all known tags&#39;. Hexadecimal tag service key for second tag filter. (optional)</param>
        /// <param name="tags2">Optional, defaults to [&#39;system:everything&#39;]. List of tags to filter the second side of pairs. (optional)</param>
        /// <param name="potentialsSearchType">Optional, integer. How the pairs should match the search(es). Default is 0. (optional)</param>
        /// <param name="pixelDuplicates">Optional, integer. Whether pairs should be pixel duplicates. Default is 1. (optional)</param>
        /// <param name="maxHammingDistance">Optional, integer. Max &#39;search distance&#39; of the pairs. Default is 4. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsGetPotentialsCountApiResponse"/>&gt;</returns>
        public async Task<IManageFileRelationshipsGetPotentialsCountApiResponse?> ManageFileRelationshipsGetPotentialsCountOrDefaultAsync(Option<string> fileServiceKey = default, Option<List<string>> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<List<string>> deletedFileServiceKeys = default, Option<string> tagServiceKey1 = default, Option<List<string>> tags1 = default, Option<string> tagServiceKey2 = default, Option<List<string>> tags2 = default, Option<int> potentialsSearchType = default, Option<int> pixelDuplicates = default, Option<int> maxHammingDistance = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ManageFileRelationshipsGetPotentialsCountAsync(fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey1, tags1, tagServiceKey2, tags2, potentialsSearchType, pixelDuplicates, maxHammingDistance, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get the count of potential duplicate file pairs Returns the count of remaining potential duplicate pairs in a specified search domain, based on given filters and search type.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileServiceKey">Hexadecimal service key for a file domain to search. (optional)</param>
        /// <param name="fileServiceKeys">List of hexadecimal service keys for a union of file domains to search. (optional)</param>
        /// <param name="deletedFileServiceKey">Hexadecimal service key for a file domain to search deleted files. (optional)</param>
        /// <param name="deletedFileServiceKeys">List of hexadecimal service keys for a union of file domains to search deleted files. (optional)</param>
        /// <param name="tagServiceKey1">Optional, defaults to &#39;all known tags&#39;. Hexadecimal tag service key. (optional)</param>
        /// <param name="tags1">Optional, defaults to [&#39;system:everything&#39;]. List of tags to filter the first side of pairs. (optional)</param>
        /// <param name="tagServiceKey2">Optional, defaults to &#39;all known tags&#39;. Hexadecimal tag service key for second tag filter. (optional)</param>
        /// <param name="tags2">Optional, defaults to [&#39;system:everything&#39;]. List of tags to filter the second side of pairs. (optional)</param>
        /// <param name="potentialsSearchType">Optional, integer. How the pairs should match the search(es). Default is 0. (optional)</param>
        /// <param name="pixelDuplicates">Optional, integer. Whether pairs should be pixel duplicates. Default is 1. (optional)</param>
        /// <param name="maxHammingDistance">Optional, integer. Max &#39;search distance&#39; of the pairs. Default is 4. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsGetPotentialsCountApiResponse"/>&gt;</returns>
        public async Task<IManageFileRelationshipsGetPotentialsCountApiResponse> ManageFileRelationshipsGetPotentialsCountAsync(Option<string> fileServiceKey = default, Option<List<string>> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<List<string>> deletedFileServiceKeys = default, Option<string> tagServiceKey1 = default, Option<List<string>> tags1 = default, Option<string> tagServiceKey2 = default, Option<List<string>> tags2 = default, Option<int> potentialsSearchType = default, Option<int> pixelDuplicates = default, Option<int> maxHammingDistance = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateManageFileRelationshipsGetPotentialsCount(fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey1, tags1, tagServiceKey2, tags2);

                FormatManageFileRelationshipsGetPotentialsCount(ref fileServiceKey, fileServiceKeys, ref deletedFileServiceKey, deletedFileServiceKeys, ref tagServiceKey1, tags1, ref tagServiceKey2, tags2, ref potentialsSearchType, ref pixelDuplicates, ref maxHammingDistance);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/manage_file_relationships/get_potentials_count"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/manage_file_relationships/get_potentials_count");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (fileServiceKey.IsSet)
                        parseQueryStringLocalVar["file_service_key"] = ClientUtils.ParameterToString(fileServiceKey.Value);

                    if (fileServiceKeys.IsSet)
                        parseQueryStringLocalVar["file_service_keys"] = ClientUtils.ParameterToString(fileServiceKeys.Value);

                    if (deletedFileServiceKey.IsSet)
                        parseQueryStringLocalVar["deleted_file_service_key"] = ClientUtils.ParameterToString(deletedFileServiceKey.Value);

                    if (deletedFileServiceKeys.IsSet)
                        parseQueryStringLocalVar["deleted_file_service_keys"] = ClientUtils.ParameterToString(deletedFileServiceKeys.Value);

                    if (tagServiceKey1.IsSet)
                        parseQueryStringLocalVar["tag_service_key_1"] = ClientUtils.ParameterToString(tagServiceKey1.Value);

                    if (tags1.IsSet)
                        parseQueryStringLocalVar["tags_1"] = ClientUtils.ParameterToString(tags1.Value);

                    if (tagServiceKey2.IsSet)
                        parseQueryStringLocalVar["tag_service_key_2"] = ClientUtils.ParameterToString(tagServiceKey2.Value);

                    if (tags2.IsSet)
                        parseQueryStringLocalVar["tags_2"] = ClientUtils.ParameterToString(tags2.Value);

                    if (potentialsSearchType.IsSet)
                        parseQueryStringLocalVar["potentials_search_type"] = ClientUtils.ParameterToString(potentialsSearchType.Value);

                    if (pixelDuplicates.IsSet)
                        parseQueryStringLocalVar["pixel_duplicates"] = ClientUtils.ParameterToString(pixelDuplicates.Value);

                    if (maxHammingDistance.IsSet)
                        parseQueryStringLocalVar["max_hamming_distance"] = ClientUtils.ParameterToString(maxHammingDistance.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Access-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Session-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ManageFileRelationshipsGetPotentialsCountApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ManageFileRelationshipsGetPotentialsCountApiResponse>();

                        ManageFileRelationshipsGetPotentialsCountApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/manage_file_relationships/get_potentials_count", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterManageFileRelationshipsGetPotentialsCountDefaultImplementation(apiResponseLocalVar, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey1, tags1, tagServiceKey2, tags2, potentialsSearchType, pixelDuplicates, maxHammingDistance);

                        Events.ExecuteOnManageFileRelationshipsGetPotentialsCount(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorManageFileRelationshipsGetPotentialsCountDefaultImplementation(e, "/manage_file_relationships/get_potentials_count", uriBuilderLocalVar.Path, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey1, tags1, tagServiceKey2, tags2, potentialsSearchType, pixelDuplicates, maxHammingDistance);
                Events.ExecuteOnErrorManageFileRelationshipsGetPotentialsCount(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ManageFileRelationshipsGetPotentialsCountApiResponse"/>
        /// </summary>
        public partial class ManageFileRelationshipsGetPotentialsCountApiResponse : HydrusAPI.NET.Client.ApiResponse, IManageFileRelationshipsGetPotentialsCountApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ManageFileRelationshipsGetPotentialsCountApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ManageFileRelationshipsGetPotentialsCountApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ManageFileRelationshipsGetPotentialsCountApiResponse(ILogger<ManageFileRelationshipsGetPotentialsCountApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public HydrusAPI.NET.Model.ManageFileRelationshipsGetPotentialsCount200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<HydrusAPI.NET.Model.ManageFileRelationshipsGetPotentialsCount200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out HydrusAPI.NET.Model.ManageFileRelationshipsGetPotentialsCount200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 419 CustomHttpStatusCode419
            /// </summary>
            /// <returns></returns>
            public bool IsCustomHttpStatusCode419 => 419 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatManageFileRelationshipsGetRandomPotentials(ref Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, ref Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, ref Option<string> tagServiceKey1, Option<List<string>> tags1, ref Option<string> tagServiceKey2, Option<List<string>> tags2, ref Option<int> potentialsSearchType, ref Option<int> pixelDuplicates, ref Option<int?> maxHammingDistance);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey1"></param>
        /// <param name="tags1"></param>
        /// <param name="tagServiceKey2"></param>
        /// <param name="tags2"></param>
        /// <returns></returns>
        private void ValidateManageFileRelationshipsGetRandomPotentials(Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey1, Option<List<string>> tags1, Option<string> tagServiceKey2, Option<List<string>> tags2)
        {
            if (fileServiceKey.IsSet && fileServiceKey.Value == null)
                throw new ArgumentNullException(nameof(fileServiceKey));

            if (fileServiceKeys.IsSet && fileServiceKeys.Value == null)
                throw new ArgumentNullException(nameof(fileServiceKeys));

            if (deletedFileServiceKey.IsSet && deletedFileServiceKey.Value == null)
                throw new ArgumentNullException(nameof(deletedFileServiceKey));

            if (deletedFileServiceKeys.IsSet && deletedFileServiceKeys.Value == null)
                throw new ArgumentNullException(nameof(deletedFileServiceKeys));

            if (tagServiceKey1.IsSet && tagServiceKey1.Value == null)
                throw new ArgumentNullException(nameof(tagServiceKey1));

            if (tags1.IsSet && tags1.Value == null)
                throw new ArgumentNullException(nameof(tags1));

            if (tagServiceKey2.IsSet && tagServiceKey2.Value == null)
                throw new ArgumentNullException(nameof(tagServiceKey2));

            if (tags2.IsSet && tags2.Value == null)
                throw new ArgumentNullException(nameof(tags2));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey1"></param>
        /// <param name="tags1"></param>
        /// <param name="tagServiceKey2"></param>
        /// <param name="tags2"></param>
        /// <param name="potentialsSearchType"></param>
        /// <param name="pixelDuplicates"></param>
        /// <param name="maxHammingDistance"></param>
        private void AfterManageFileRelationshipsGetRandomPotentialsDefaultImplementation(IManageFileRelationshipsGetRandomPotentialsApiResponse apiResponseLocalVar, Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey1, Option<List<string>> tags1, Option<string> tagServiceKey2, Option<List<string>> tags2, Option<int> potentialsSearchType, Option<int> pixelDuplicates, Option<int?> maxHammingDistance)
        {
            bool suppressDefaultLog = false;
            AfterManageFileRelationshipsGetRandomPotentials(ref suppressDefaultLog, apiResponseLocalVar, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey1, tags1, tagServiceKey2, tags2, potentialsSearchType, pixelDuplicates, maxHammingDistance);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey1"></param>
        /// <param name="tags1"></param>
        /// <param name="tagServiceKey2"></param>
        /// <param name="tags2"></param>
        /// <param name="potentialsSearchType"></param>
        /// <param name="pixelDuplicates"></param>
        /// <param name="maxHammingDistance"></param>
        partial void AfterManageFileRelationshipsGetRandomPotentials(ref bool suppressDefaultLog, IManageFileRelationshipsGetRandomPotentialsApiResponse apiResponseLocalVar, Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey1, Option<List<string>> tags1, Option<string> tagServiceKey2, Option<List<string>> tags2, Option<int> potentialsSearchType, Option<int> pixelDuplicates, Option<int?> maxHammingDistance);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey1"></param>
        /// <param name="tags1"></param>
        /// <param name="tagServiceKey2"></param>
        /// <param name="tags2"></param>
        /// <param name="potentialsSearchType"></param>
        /// <param name="pixelDuplicates"></param>
        /// <param name="maxHammingDistance"></param>
        private void OnErrorManageFileRelationshipsGetRandomPotentialsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey1, Option<List<string>> tags1, Option<string> tagServiceKey2, Option<List<string>> tags2, Option<int> potentialsSearchType, Option<int> pixelDuplicates, Option<int?> maxHammingDistance)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorManageFileRelationshipsGetRandomPotentials(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey1, tags1, tagServiceKey2, tags2, potentialsSearchType, pixelDuplicates, maxHammingDistance);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey1"></param>
        /// <param name="tags1"></param>
        /// <param name="tagServiceKey2"></param>
        /// <param name="tags2"></param>
        /// <param name="potentialsSearchType"></param>
        /// <param name="pixelDuplicates"></param>
        /// <param name="maxHammingDistance"></param>
        partial void OnErrorManageFileRelationshipsGetRandomPotentials(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey1, Option<List<string>> tags1, Option<string> tagServiceKey2, Option<List<string>> tags2, Option<int> potentialsSearchType, Option<int> pixelDuplicates, Option<int?> maxHammingDistance);

        /// <summary>
        /// Get some random potentially duplicate file hashes. Exactly the same as the &#39;show some random potential dupes&#39; button in the duplicate processing page.
        /// </summary>
        /// <param name="fileServiceKey"> (optional)</param>
        /// <param name="fileServiceKeys"> (optional)</param>
        /// <param name="deletedFileServiceKey"> (optional)</param>
        /// <param name="deletedFileServiceKeys"> (optional)</param>
        /// <param name="tagServiceKey1"> (optional)</param>
        /// <param name="tags1"> (optional)</param>
        /// <param name="tagServiceKey2"> (optional)</param>
        /// <param name="tags2"> (optional)</param>
        /// <param name="potentialsSearchType"> (optional)</param>
        /// <param name="pixelDuplicates"> (optional)</param>
        /// <param name="maxHammingDistance"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsGetRandomPotentialsApiResponse"/>&gt;</returns>
        public async Task<IManageFileRelationshipsGetRandomPotentialsApiResponse?> ManageFileRelationshipsGetRandomPotentialsOrDefaultAsync(Option<string> fileServiceKey = default, Option<List<string>> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<List<string>> deletedFileServiceKeys = default, Option<string> tagServiceKey1 = default, Option<List<string>> tags1 = default, Option<string> tagServiceKey2 = default, Option<List<string>> tags2 = default, Option<int> potentialsSearchType = default, Option<int> pixelDuplicates = default, Option<int?> maxHammingDistance = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ManageFileRelationshipsGetRandomPotentialsAsync(fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey1, tags1, tagServiceKey2, tags2, potentialsSearchType, pixelDuplicates, maxHammingDistance, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get some random potentially duplicate file hashes. Exactly the same as the &#39;show some random potential dupes&#39; button in the duplicate processing page.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileServiceKey"> (optional)</param>
        /// <param name="fileServiceKeys"> (optional)</param>
        /// <param name="deletedFileServiceKey"> (optional)</param>
        /// <param name="deletedFileServiceKeys"> (optional)</param>
        /// <param name="tagServiceKey1"> (optional)</param>
        /// <param name="tags1"> (optional)</param>
        /// <param name="tagServiceKey2"> (optional)</param>
        /// <param name="tags2"> (optional)</param>
        /// <param name="potentialsSearchType"> (optional)</param>
        /// <param name="pixelDuplicates"> (optional)</param>
        /// <param name="maxHammingDistance"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsGetRandomPotentialsApiResponse"/>&gt;</returns>
        public async Task<IManageFileRelationshipsGetRandomPotentialsApiResponse> ManageFileRelationshipsGetRandomPotentialsAsync(Option<string> fileServiceKey = default, Option<List<string>> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<List<string>> deletedFileServiceKeys = default, Option<string> tagServiceKey1 = default, Option<List<string>> tags1 = default, Option<string> tagServiceKey2 = default, Option<List<string>> tags2 = default, Option<int> potentialsSearchType = default, Option<int> pixelDuplicates = default, Option<int?> maxHammingDistance = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateManageFileRelationshipsGetRandomPotentials(fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey1, tags1, tagServiceKey2, tags2);

                FormatManageFileRelationshipsGetRandomPotentials(ref fileServiceKey, fileServiceKeys, ref deletedFileServiceKey, deletedFileServiceKeys, ref tagServiceKey1, tags1, ref tagServiceKey2, tags2, ref potentialsSearchType, ref pixelDuplicates, ref maxHammingDistance);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/manage_file_relationships/get_random_potentials"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/manage_file_relationships/get_random_potentials");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (fileServiceKey.IsSet)
                        parseQueryStringLocalVar["file_service_key"] = ClientUtils.ParameterToString(fileServiceKey.Value);

                    if (fileServiceKeys.IsSet)
                        parseQueryStringLocalVar["file_service_keys"] = ClientUtils.ParameterToString(fileServiceKeys.Value);

                    if (deletedFileServiceKey.IsSet)
                        parseQueryStringLocalVar["deleted_file_service_key"] = ClientUtils.ParameterToString(deletedFileServiceKey.Value);

                    if (deletedFileServiceKeys.IsSet)
                        parseQueryStringLocalVar["deleted_file_service_keys"] = ClientUtils.ParameterToString(deletedFileServiceKeys.Value);

                    if (tagServiceKey1.IsSet)
                        parseQueryStringLocalVar["tag_service_key_1"] = ClientUtils.ParameterToString(tagServiceKey1.Value);

                    if (tags1.IsSet)
                        parseQueryStringLocalVar["tags_1"] = ClientUtils.ParameterToString(tags1.Value);

                    if (tagServiceKey2.IsSet)
                        parseQueryStringLocalVar["tag_service_key_2"] = ClientUtils.ParameterToString(tagServiceKey2.Value);

                    if (tags2.IsSet)
                        parseQueryStringLocalVar["tags_2"] = ClientUtils.ParameterToString(tags2.Value);

                    if (potentialsSearchType.IsSet)
                        parseQueryStringLocalVar["potentials_search_type"] = ClientUtils.ParameterToString(potentialsSearchType.Value);

                    if (pixelDuplicates.IsSet)
                        parseQueryStringLocalVar["pixel_duplicates"] = ClientUtils.ParameterToString(pixelDuplicates.Value);

                    if (maxHammingDistance.IsSet)
                        parseQueryStringLocalVar["max_hamming_distance"] = ClientUtils.ParameterToString(maxHammingDistance.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Access-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Session-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json",
                        "application/cbor"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ManageFileRelationshipsGetRandomPotentialsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ManageFileRelationshipsGetRandomPotentialsApiResponse>();

                        ManageFileRelationshipsGetRandomPotentialsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/manage_file_relationships/get_random_potentials", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterManageFileRelationshipsGetRandomPotentialsDefaultImplementation(apiResponseLocalVar, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey1, tags1, tagServiceKey2, tags2, potentialsSearchType, pixelDuplicates, maxHammingDistance);

                        Events.ExecuteOnManageFileRelationshipsGetRandomPotentials(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorManageFileRelationshipsGetRandomPotentialsDefaultImplementation(e, "/manage_file_relationships/get_random_potentials", uriBuilderLocalVar.Path, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey1, tags1, tagServiceKey2, tags2, potentialsSearchType, pixelDuplicates, maxHammingDistance);
                Events.ExecuteOnErrorManageFileRelationshipsGetRandomPotentials(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ManageFileRelationshipsGetRandomPotentialsApiResponse"/>
        /// </summary>
        public partial class ManageFileRelationshipsGetRandomPotentialsApiResponse : HydrusAPI.NET.Client.ApiResponse, IManageFileRelationshipsGetRandomPotentialsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ManageFileRelationshipsGetRandomPotentialsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ManageFileRelationshipsGetRandomPotentialsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ManageFileRelationshipsGetRandomPotentialsApiResponse(ILogger<ManageFileRelationshipsGetRandomPotentialsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public HydrusAPI.NET.Model.ManageFileRelationshipsGetRandomPotentials200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<HydrusAPI.NET.Model.ManageFileRelationshipsGetRandomPotentials200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out HydrusAPI.NET.Model.ManageFileRelationshipsGetRandomPotentials200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 419 CustomHttpStatusCode419
            /// </summary>
            /// <returns></returns>
            public bool IsCustomHttpStatusCode419 => 419 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatManageFileRelationshipsRemovePotentials(Files? files);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="files"></param>
        private void AfterManageFileRelationshipsRemovePotentialsDefaultImplementation(IManageFileRelationshipsRemovePotentialsApiResponse apiResponseLocalVar, Files? files)
        {
            bool suppressDefaultLog = false;
            AfterManageFileRelationshipsRemovePotentials(ref suppressDefaultLog, apiResponseLocalVar, files);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="files"></param>
        partial void AfterManageFileRelationshipsRemovePotentials(ref bool suppressDefaultLog, IManageFileRelationshipsRemovePotentialsApiResponse apiResponseLocalVar, Files? files);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="files"></param>
        private void OnErrorManageFileRelationshipsRemovePotentialsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Files? files)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorManageFileRelationshipsRemovePotentials(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, files);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="files"></param>
        partial void OnErrorManageFileRelationshipsRemovePotentials(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Files? files);

        /// <summary>
        /// Remove all potential file relationships for specified files Removes all potential pairs that any of the specified files are a part of. This operation ensures that the files will no longer appear as part of any potential relationships.
        /// </summary>
        /// <param name="files"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsRemovePotentialsApiResponse"/>&gt;</returns>
        public async Task<IManageFileRelationshipsRemovePotentialsApiResponse?> ManageFileRelationshipsRemovePotentialsOrDefaultAsync(Files? files = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ManageFileRelationshipsRemovePotentialsAsync(files, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Remove all potential file relationships for specified files Removes all potential pairs that any of the specified files are a part of. This operation ensures that the files will no longer appear as part of any potential relationships.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="files"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsRemovePotentialsApiResponse"/>&gt;</returns>
        public async Task<IManageFileRelationshipsRemovePotentialsApiResponse> ManageFileRelationshipsRemovePotentialsAsync(Files? files = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatManageFileRelationshipsRemovePotentials(files);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/manage_file_relationships/remove_potentials"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/manage_file_relationships/remove_potentials");

                    httpRequestMessageLocalVar.Content = (files as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(files, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Access-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Session-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ManageFileRelationshipsRemovePotentialsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ManageFileRelationshipsRemovePotentialsApiResponse>();

                        ManageFileRelationshipsRemovePotentialsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/manage_file_relationships/remove_potentials", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterManageFileRelationshipsRemovePotentialsDefaultImplementation(apiResponseLocalVar, files);

                        Events.ExecuteOnManageFileRelationshipsRemovePotentials(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorManageFileRelationshipsRemovePotentialsDefaultImplementation(e, "/manage_file_relationships/remove_potentials", uriBuilderLocalVar.Path, files);
                Events.ExecuteOnErrorManageFileRelationshipsRemovePotentials(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ManageFileRelationshipsRemovePotentialsApiResponse"/>
        /// </summary>
        public partial class ManageFileRelationshipsRemovePotentialsApiResponse : HydrusAPI.NET.Client.ApiResponse, IManageFileRelationshipsRemovePotentialsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ManageFileRelationshipsRemovePotentialsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ManageFileRelationshipsRemovePotentialsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ManageFileRelationshipsRemovePotentialsApiResponse(ILogger<ManageFileRelationshipsRemovePotentialsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 419 CustomHttpStatusCode419
            /// </summary>
            /// <returns></returns>
            public bool IsCustomHttpStatusCode419 => 419 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatManageFileRelationshipsSetFileRelationships(ManageFileRelationshipsSetFileRelationshipsRequest manageFileRelationshipsSetFileRelationshipsRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="manageFileRelationshipsSetFileRelationshipsRequest"></param>
        /// <returns></returns>
        private void ValidateManageFileRelationshipsSetFileRelationships(ManageFileRelationshipsSetFileRelationshipsRequest manageFileRelationshipsSetFileRelationshipsRequest)
        {
            if (manageFileRelationshipsSetFileRelationshipsRequest == null)
                throw new ArgumentNullException(nameof(manageFileRelationshipsSetFileRelationshipsRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="manageFileRelationshipsSetFileRelationshipsRequest"></param>
        private void AfterManageFileRelationshipsSetFileRelationshipsDefaultImplementation(IManageFileRelationshipsSetFileRelationshipsApiResponse apiResponseLocalVar, ManageFileRelationshipsSetFileRelationshipsRequest manageFileRelationshipsSetFileRelationshipsRequest)
        {
            bool suppressDefaultLog = false;
            AfterManageFileRelationshipsSetFileRelationships(ref suppressDefaultLog, apiResponseLocalVar, manageFileRelationshipsSetFileRelationshipsRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="manageFileRelationshipsSetFileRelationshipsRequest"></param>
        partial void AfterManageFileRelationshipsSetFileRelationships(ref bool suppressDefaultLog, IManageFileRelationshipsSetFileRelationshipsApiResponse apiResponseLocalVar, ManageFileRelationshipsSetFileRelationshipsRequest manageFileRelationshipsSetFileRelationshipsRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="manageFileRelationshipsSetFileRelationshipsRequest"></param>
        private void OnErrorManageFileRelationshipsSetFileRelationshipsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, ManageFileRelationshipsSetFileRelationshipsRequest manageFileRelationshipsSetFileRelationshipsRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorManageFileRelationshipsSetFileRelationships(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, manageFileRelationshipsSetFileRelationshipsRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="manageFileRelationshipsSetFileRelationshipsRequest"></param>
        partial void OnErrorManageFileRelationshipsSetFileRelationships(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, ManageFileRelationshipsSetFileRelationshipsRequest manageFileRelationshipsSetFileRelationshipsRequest);

        /// <summary>
        /// Set file relationships Set relationships (e.g., duplicates, alternates, same quality) between pairs of files.
        /// </summary>
        /// <param name="manageFileRelationshipsSetFileRelationshipsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsSetFileRelationshipsApiResponse"/>&gt;</returns>
        public async Task<IManageFileRelationshipsSetFileRelationshipsApiResponse?> ManageFileRelationshipsSetFileRelationshipsOrDefaultAsync(ManageFileRelationshipsSetFileRelationshipsRequest manageFileRelationshipsSetFileRelationshipsRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ManageFileRelationshipsSetFileRelationshipsAsync(manageFileRelationshipsSetFileRelationshipsRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Set file relationships Set relationships (e.g., duplicates, alternates, same quality) between pairs of files.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="manageFileRelationshipsSetFileRelationshipsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsSetFileRelationshipsApiResponse"/>&gt;</returns>
        public async Task<IManageFileRelationshipsSetFileRelationshipsApiResponse> ManageFileRelationshipsSetFileRelationshipsAsync(ManageFileRelationshipsSetFileRelationshipsRequest manageFileRelationshipsSetFileRelationshipsRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateManageFileRelationshipsSetFileRelationships(manageFileRelationshipsSetFileRelationshipsRequest);

                FormatManageFileRelationshipsSetFileRelationships(manageFileRelationshipsSetFileRelationshipsRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/manage_file_relationships/set_file_relationships"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/manage_file_relationships/set_file_relationships");

                    httpRequestMessageLocalVar.Content = (manageFileRelationshipsSetFileRelationshipsRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(manageFileRelationshipsSetFileRelationshipsRequest, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Access-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Session-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ManageFileRelationshipsSetFileRelationshipsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ManageFileRelationshipsSetFileRelationshipsApiResponse>();

                        ManageFileRelationshipsSetFileRelationshipsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/manage_file_relationships/set_file_relationships", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterManageFileRelationshipsSetFileRelationshipsDefaultImplementation(apiResponseLocalVar, manageFileRelationshipsSetFileRelationshipsRequest);

                        Events.ExecuteOnManageFileRelationshipsSetFileRelationships(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorManageFileRelationshipsSetFileRelationshipsDefaultImplementation(e, "/manage_file_relationships/set_file_relationships", uriBuilderLocalVar.Path, manageFileRelationshipsSetFileRelationshipsRequest);
                Events.ExecuteOnErrorManageFileRelationshipsSetFileRelationships(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ManageFileRelationshipsSetFileRelationshipsApiResponse"/>
        /// </summary>
        public partial class ManageFileRelationshipsSetFileRelationshipsApiResponse : HydrusAPI.NET.Client.ApiResponse, IManageFileRelationshipsSetFileRelationshipsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ManageFileRelationshipsSetFileRelationshipsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ManageFileRelationshipsSetFileRelationshipsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ManageFileRelationshipsSetFileRelationshipsApiResponse(ILogger<ManageFileRelationshipsSetFileRelationshipsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatManageFileRelationshipsSetKings(ManageFileRelationshipsSetKingsRequest? manageFileRelationshipsSetKingsRequest);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="manageFileRelationshipsSetKingsRequest"></param>
        private void AfterManageFileRelationshipsSetKingsDefaultImplementation(IManageFileRelationshipsSetKingsApiResponse apiResponseLocalVar, ManageFileRelationshipsSetKingsRequest? manageFileRelationshipsSetKingsRequest)
        {
            bool suppressDefaultLog = false;
            AfterManageFileRelationshipsSetKings(ref suppressDefaultLog, apiResponseLocalVar, manageFileRelationshipsSetKingsRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="manageFileRelationshipsSetKingsRequest"></param>
        partial void AfterManageFileRelationshipsSetKings(ref bool suppressDefaultLog, IManageFileRelationshipsSetKingsApiResponse apiResponseLocalVar, ManageFileRelationshipsSetKingsRequest? manageFileRelationshipsSetKingsRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="manageFileRelationshipsSetKingsRequest"></param>
        private void OnErrorManageFileRelationshipsSetKingsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, ManageFileRelationshipsSetKingsRequest? manageFileRelationshipsSetKingsRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorManageFileRelationshipsSetKings(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, manageFileRelationshipsSetKingsRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="manageFileRelationshipsSetKingsRequest"></param>
        partial void OnErrorManageFileRelationshipsSetKings(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, ManageFileRelationshipsSetKingsRequest? manageFileRelationshipsSetKingsRequest);

        /// <summary>
        /// Set files as kings of their duplicate groups Promotes the specified files to be the \&quot;king\&quot; of their respective duplicate groups. This operation is idempotent and processes files in the order they are provided.
        /// </summary>
        /// <param name="manageFileRelationshipsSetKingsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsSetKingsApiResponse"/>&gt;</returns>
        public async Task<IManageFileRelationshipsSetKingsApiResponse?> ManageFileRelationshipsSetKingsOrDefaultAsync(ManageFileRelationshipsSetKingsRequest? manageFileRelationshipsSetKingsRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ManageFileRelationshipsSetKingsAsync(manageFileRelationshipsSetKingsRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Set files as kings of their duplicate groups Promotes the specified files to be the \&quot;king\&quot; of their respective duplicate groups. This operation is idempotent and processes files in the order they are provided.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="manageFileRelationshipsSetKingsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IManageFileRelationshipsSetKingsApiResponse"/>&gt;</returns>
        public async Task<IManageFileRelationshipsSetKingsApiResponse> ManageFileRelationshipsSetKingsAsync(ManageFileRelationshipsSetKingsRequest? manageFileRelationshipsSetKingsRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatManageFileRelationshipsSetKings(manageFileRelationshipsSetKingsRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/manage_file_relationships/set_kings"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/manage_file_relationships/set_kings");

                    httpRequestMessageLocalVar.Content = (manageFileRelationshipsSetKingsRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(manageFileRelationshipsSetKingsRequest, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Access-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Session-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ManageFileRelationshipsSetKingsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ManageFileRelationshipsSetKingsApiResponse>();

                        ManageFileRelationshipsSetKingsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/manage_file_relationships/set_kings", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterManageFileRelationshipsSetKingsDefaultImplementation(apiResponseLocalVar, manageFileRelationshipsSetKingsRequest);

                        Events.ExecuteOnManageFileRelationshipsSetKings(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorManageFileRelationshipsSetKingsDefaultImplementation(e, "/manage_file_relationships/set_kings", uriBuilderLocalVar.Path, manageFileRelationshipsSetKingsRequest);
                Events.ExecuteOnErrorManageFileRelationshipsSetKings(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ManageFileRelationshipsSetKingsApiResponse"/>
        /// </summary>
        public partial class ManageFileRelationshipsSetKingsApiResponse : HydrusAPI.NET.Client.ApiResponse, IManageFileRelationshipsSetKingsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ManageFileRelationshipsSetKingsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ManageFileRelationshipsSetKingsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ManageFileRelationshipsSetKingsApiResponse(ILogger<ManageFileRelationshipsSetKingsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 419 CustomHttpStatusCode419
            /// </summary>
            /// <returns></returns>
            public bool IsCustomHttpStatusCode419 => 419 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
