// <auto-generated>
/*
 * Hydrus Client API
 *
 * API for interacting with the Hydrus Client
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using HydrusAPI.NET.Client;
using HydrusAPI.NET.Model;
using System.Diagnostics.CodeAnalysis;

namespace HydrusAPI.NET.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IGetFilesApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        GetFilesApiEvents Events { get; }

        /// <summary>
        /// Get a file
        /// </summary>
        /// <remarks>
        /// Retrieves a file based on &#x60;file_id&#x60; or &#x60;hash&#x60;. Requires appropriate access permissions.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileId">Numerical file ID for the file. (optional)</param>
        /// <param name="hash">Hexadecimal SHA256 hash for the file. Can only be used if the user has access to all files. (optional)</param>
        /// <param name="download">If true, sets &#x60;Content-Disposition&#x60; to &#x60;attachment&#x60;, prompting a download in browsers. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesFileApiResponse"/>&gt;</returns>
        Task<IGetFilesFileApiResponse> GetFilesFileAsync(Option<int> fileId = default, Option<string> hash = default, Option<bool> download = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a file
        /// </summary>
        /// <remarks>
        /// Retrieves a file based on &#x60;file_id&#x60; or &#x60;hash&#x60;. Requires appropriate access permissions.
        /// </remarks>
        /// <param name="fileId">Numerical file ID for the file. (optional)</param>
        /// <param name="hash">Hexadecimal SHA256 hash for the file. Can only be used if the user has access to all files. (optional)</param>
        /// <param name="download">If true, sets &#x60;Content-Disposition&#x60; to &#x60;attachment&#x60;, prompting a download in browsers. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesFileApiResponse"/>?&gt;</returns>
        Task<IGetFilesFileApiResponse?> GetFilesFileOrDefaultAsync(Option<int> fileId = default, Option<string> hash = default, Option<bool> download = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Lookup file hashes from other hashes
        /// </summary>
        /// <remarks>
        /// Converts hashes between types (e.g., MD5 to SHA256)
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="desiredHashType"></param>
        /// <param name="hash"> (optional)</param>
        /// <param name="hashes"> (optional)</param>
        /// <param name="sourceHashType"> (optional, default to sha256)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesFileHashesApiResponse"/>&gt;</returns>
        Task<IGetFilesFileHashesApiResponse> GetFilesFileHashesAsync(string desiredHashType, Option<string> hash = default, Option<List<string>> hashes = default, Option<string> sourceHashType = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Lookup file hashes from other hashes
        /// </summary>
        /// <remarks>
        /// Converts hashes between types (e.g., MD5 to SHA256)
        /// </remarks>
        /// <param name="desiredHashType"></param>
        /// <param name="hash"> (optional)</param>
        /// <param name="hashes"> (optional)</param>
        /// <param name="sourceHashType"> (optional, default to sha256)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesFileHashesApiResponse"/>?&gt;</returns>
        Task<IGetFilesFileHashesApiResponse?> GetFilesFileHashesOrDefaultAsync(string desiredHashType, Option<string> hash = default, Option<List<string>> hashes = default, Option<string> sourceHashType = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get metadata about files in the client
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileId"> (optional)</param>
        /// <param name="fileIds"> (optional)</param>
        /// <param name="hash"> (optional)</param>
        /// <param name="hashes"> (optional)</param>
        /// <param name="createNewFileIds"> (optional)</param>
        /// <param name="onlyReturnIdentifiers"> (optional)</param>
        /// <param name="onlyReturnBasicInformation"> (optional)</param>
        /// <param name="detailedUrlInformation"> (optional)</param>
        /// <param name="includeBlurhash"> (optional)</param>
        /// <param name="includeMilliseconds"> (optional)</param>
        /// <param name="includeNotes"> (optional)</param>
        /// <param name="includeServicesObject"> (optional)</param>
        /// <param name="hideServiceKeysTags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesFileMetadataApiResponse"/>&gt;</returns>
        Task<IGetFilesFileMetadataApiResponse> GetFilesFileMetadataAsync(Option<int> fileId = default, Option<List<int>> fileIds = default, Option<string> hash = default, Option<List<string>> hashes = default, Option<bool> createNewFileIds = default, Option<bool> onlyReturnIdentifiers = default, Option<bool> onlyReturnBasicInformation = default, Option<bool> detailedUrlInformation = default, Option<bool> includeBlurhash = default, Option<bool> includeMilliseconds = default, Option<bool> includeNotes = default, Option<bool> includeServicesObject = default, Option<bool> hideServiceKeysTags = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get metadata about files in the client
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="fileId"> (optional)</param>
        /// <param name="fileIds"> (optional)</param>
        /// <param name="hash"> (optional)</param>
        /// <param name="hashes"> (optional)</param>
        /// <param name="createNewFileIds"> (optional)</param>
        /// <param name="onlyReturnIdentifiers"> (optional)</param>
        /// <param name="onlyReturnBasicInformation"> (optional)</param>
        /// <param name="detailedUrlInformation"> (optional)</param>
        /// <param name="includeBlurhash"> (optional)</param>
        /// <param name="includeMilliseconds"> (optional)</param>
        /// <param name="includeNotes"> (optional)</param>
        /// <param name="includeServicesObject"> (optional)</param>
        /// <param name="hideServiceKeysTags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesFileMetadataApiResponse"/>?&gt;</returns>
        Task<IGetFilesFileMetadataApiResponse?> GetFilesFileMetadataOrDefaultAsync(Option<int> fileId = default, Option<List<int>> fileIds = default, Option<string> hash = default, Option<List<string>> hashes = default, Option<bool> createNewFileIds = default, Option<bool> onlyReturnIdentifiers = default, Option<bool> onlyReturnBasicInformation = default, Option<bool> detailedUrlInformation = default, Option<bool> includeBlurhash = default, Option<bool> includeMilliseconds = default, Option<bool> includeNotes = default, Option<bool> includeServicesObject = default, Option<bool> hideServiceKeysTags = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get the local file path and metadata.
        /// </summary>
        /// <remarks>
        /// Retrieves the local file system path, filetype, and size for a specified file either by &#x60;file_id&#x60; or &#x60;hash&#x60;.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileId"> (optional)</param>
        /// <param name="hash"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesFilePathApiResponse"/>&gt;</returns>
        Task<IGetFilesFilePathApiResponse> GetFilesFilePathAsync(Option<int> fileId = default, Option<string> hash = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get the local file path and metadata.
        /// </summary>
        /// <remarks>
        /// Retrieves the local file system path, filetype, and size for a specified file either by &#x60;file_id&#x60; or &#x60;hash&#x60;.
        /// </remarks>
        /// <param name="fileId"> (optional)</param>
        /// <param name="hash"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesFilePathApiResponse"/>?&gt;</returns>
        Task<IGetFilesFilePathApiResponse?> GetFilesFilePathOrDefaultAsync(Option<int> fileId = default, Option<string> hash = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an image or ugoira file as rendered by Hydrus
        /// </summary>
        /// <remarks>
        /// Retrieves a file (image or ugoira) rendered by Hydrus, optionally resized or converted to a specific format.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileId"> (optional)</param>
        /// <param name="hash"> (optional)</param>
        /// <param name="download"> (optional, default to false)</param>
        /// <param name="renderFormat"> (optional)</param>
        /// <param name="renderQuality"> (optional)</param>
        /// <param name="width"> (optional)</param>
        /// <param name="height"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesRenderApiResponse"/>&gt;</returns>
        Task<IGetFilesRenderApiResponse> GetFilesRenderAsync(Option<int> fileId = default, Option<string> hash = default, Option<bool> download = default, Option<int> renderFormat = default, Option<int> renderQuality = default, Option<int> width = default, Option<int> height = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an image or ugoira file as rendered by Hydrus
        /// </summary>
        /// <remarks>
        /// Retrieves a file (image or ugoira) rendered by Hydrus, optionally resized or converted to a specific format.
        /// </remarks>
        /// <param name="fileId"> (optional)</param>
        /// <param name="hash"> (optional)</param>
        /// <param name="download"> (optional, default to false)</param>
        /// <param name="renderFormat"> (optional)</param>
        /// <param name="renderQuality"> (optional)</param>
        /// <param name="width"> (optional)</param>
        /// <param name="height"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesRenderApiResponse"/>?&gt;</returns>
        Task<IGetFilesRenderApiResponse?> GetFilesRenderOrDefaultAsync(Option<int> fileId = default, Option<string> hash = default, Option<bool> download = default, Option<int> renderFormat = default, Option<int> renderQuality = default, Option<int> width = default, Option<int> height = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search for the client&#39;s files.
        /// </summary>
        /// <remarks>
        /// Search for files using tags and system predicates. Supports complex search logic including wildcards, negation, and system predicates like file size, resolution, and time filters.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tags"></param>
        /// <param name="fileServiceKey"> (optional)</param>
        /// <param name="fileServiceKeys"> (optional)</param>
        /// <param name="deletedFileServiceKey"> (optional)</param>
        /// <param name="deletedFileServiceKeys"> (optional)</param>
        /// <param name="tagServiceKey"> (optional)</param>
        /// <param name="includeCurrentTags"> (optional, default to true)</param>
        /// <param name="includePendingTags"> (optional, default to true)</param>
        /// <param name="fileSortType"> (optional, default to 2)</param>
        /// <param name="fileSortAsc"> (optional, default to false)</param>
        /// <param name="returnFileIds"> (optional, default to true)</param>
        /// <param name="returnHashes"> (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesSearchFilesApiResponse"/>&gt;</returns>
        Task<IGetFilesSearchFilesApiResponse> GetFilesSearchFilesAsync(List<string> tags, Option<string> fileServiceKey = default, Option<List<string>> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<List<string>> deletedFileServiceKeys = default, Option<string> tagServiceKey = default, Option<bool> includeCurrentTags = default, Option<bool> includePendingTags = default, Option<int> fileSortType = default, Option<bool> fileSortAsc = default, Option<bool> returnFileIds = default, Option<bool> returnHashes = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Search for the client&#39;s files.
        /// </summary>
        /// <remarks>
        /// Search for files using tags and system predicates. Supports complex search logic including wildcards, negation, and system predicates like file size, resolution, and time filters.
        /// </remarks>
        /// <param name="tags"></param>
        /// <param name="fileServiceKey"> (optional)</param>
        /// <param name="fileServiceKeys"> (optional)</param>
        /// <param name="deletedFileServiceKey"> (optional)</param>
        /// <param name="deletedFileServiceKeys"> (optional)</param>
        /// <param name="tagServiceKey"> (optional)</param>
        /// <param name="includeCurrentTags"> (optional, default to true)</param>
        /// <param name="includePendingTags"> (optional, default to true)</param>
        /// <param name="fileSortType"> (optional, default to 2)</param>
        /// <param name="fileSortAsc"> (optional, default to false)</param>
        /// <param name="returnFileIds"> (optional, default to true)</param>
        /// <param name="returnHashes"> (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesSearchFilesApiResponse"/>?&gt;</returns>
        Task<IGetFilesSearchFilesApiResponse?> GetFilesSearchFilesOrDefaultAsync(List<string> tags, Option<string> fileServiceKey = default, Option<List<string>> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<List<string>> deletedFileServiceKeys = default, Option<string> tagServiceKey = default, Option<bool> includeCurrentTags = default, Option<bool> includePendingTags = default, Option<int> fileSortType = default, Option<bool> fileSortAsc = default, Option<bool> returnFileIds = default, Option<bool> returnHashes = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a file&#39;s thumbnail
        /// </summary>
        /// <remarks>
        /// Retrieves the thumbnail for a specific file based on either a file ID or hash. Returns default icons if the thumbnail doesn&#39;t exist.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileId">Numerical file ID for the file. (optional)</param>
        /// <param name="hash">Hexadecimal SHA256 hash for the file. Can only be used if access to all files is granted. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesThumbnailApiResponse"/>&gt;</returns>
        Task<IGetFilesThumbnailApiResponse> GetFilesThumbnailAsync(Option<int> fileId = default, Option<string> hash = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a file&#39;s thumbnail
        /// </summary>
        /// <remarks>
        /// Retrieves the thumbnail for a specific file based on either a file ID or hash. Returns default icons if the thumbnail doesn&#39;t exist.
        /// </remarks>
        /// <param name="fileId">Numerical file ID for the file. (optional)</param>
        /// <param name="hash">Hexadecimal SHA256 hash for the file. Can only be used if access to all files is granted. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesThumbnailApiResponse"/>?&gt;</returns>
        Task<IGetFilesThumbnailApiResponse?> GetFilesThumbnailOrDefaultAsync(Option<int> fileId = default, Option<string> hash = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get the local thumbnail path for a file.
        /// </summary>
        /// <remarks>
        /// Returns the local file system path to the thumbnail of the specified file. Optionally includes the thumbnail&#39;s filetype.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileId"> (optional)</param>
        /// <param name="hash"> (optional)</param>
        /// <param name="includeThumbnailFiletype"> (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesThumbnailPathApiResponse"/>&gt;</returns>
        Task<IGetFilesThumbnailPathApiResponse> GetFilesThumbnailPathAsync(Option<int> fileId = default, Option<string> hash = default, Option<bool> includeThumbnailFiletype = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get the local thumbnail path for a file.
        /// </summary>
        /// <remarks>
        /// Returns the local file system path to the thumbnail of the specified file. Optionally includes the thumbnail&#39;s filetype.
        /// </remarks>
        /// <param name="fileId"> (optional)</param>
        /// <param name="hash"> (optional)</param>
        /// <param name="includeThumbnailFiletype"> (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesThumbnailPathApiResponse"/>?&gt;</returns>
        Task<IGetFilesThumbnailPathApiResponse?> GetFilesThumbnailPathOrDefaultAsync(Option<int> fileId = default, Option<string> hash = default, Option<bool> includeThumbnailFiletype = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get local file storage locations
        /// </summary>
        /// <remarks>
        /// Returns the local file storage locations as seen under **database-&gt;migrate files**.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLocalFileStorageLocationsApiResponse"/>&gt;</returns>
        Task<IGetLocalFileStorageLocationsApiResponse> GetLocalFileStorageLocationsAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get local file storage locations
        /// </summary>
        /// <remarks>
        /// Returns the local file storage locations as seen under **database-&gt;migrate files**.
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLocalFileStorageLocationsApiResponse"/>?&gt;</returns>
        Task<IGetLocalFileStorageLocationsApiResponse?> GetLocalFileStorageLocationsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IGetFilesFileApiResponse"/>
    /// </summary>
    public interface IGetFilesFileApiResponse : HydrusAPI.NET.Client.IApiResponse, IOk<System.IO.Stream?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 419 CustomHttpStatusCode419
        /// </summary>
        /// <returns></returns>
        bool IsCustomHttpStatusCode419 { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetFilesFileHashesApiResponse"/>
    /// </summary>
    public interface IGetFilesFileHashesApiResponse : HydrusAPI.NET.Client.IApiResponse, IOk<HydrusAPI.NET.Model.GetFilesFileHashes200Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 419 CustomHttpStatusCode419
        /// </summary>
        /// <returns></returns>
        bool IsCustomHttpStatusCode419 { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetFilesFileMetadataApiResponse"/>
    /// </summary>
    public interface IGetFilesFileMetadataApiResponse : HydrusAPI.NET.Client.IApiResponse, IOk<HydrusAPI.NET.Model.GetFilesFileMetadata200Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetFilesFilePathApiResponse"/>
    /// </summary>
    public interface IGetFilesFilePathApiResponse : HydrusAPI.NET.Client.IApiResponse, IOk<HydrusAPI.NET.Model.GetFilesFilePath200Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetFilesRenderApiResponse"/>
    /// </summary>
    public interface IGetFilesRenderApiResponse : HydrusAPI.NET.Client.IApiResponse, IOk<System.IO.Stream?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 419 CustomHttpStatusCode419
        /// </summary>
        /// <returns></returns>
        bool IsCustomHttpStatusCode419 { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetFilesSearchFilesApiResponse"/>
    /// </summary>
    public interface IGetFilesSearchFilesApiResponse : HydrusAPI.NET.Client.IApiResponse, IOk<HydrusAPI.NET.Model.GetFilesSearchFiles200Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 419 CustomHttpStatusCode419
        /// </summary>
        /// <returns></returns>
        bool IsCustomHttpStatusCode419 { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetFilesThumbnailApiResponse"/>
    /// </summary>
    public interface IGetFilesThumbnailApiResponse : HydrusAPI.NET.Client.IApiResponse, IOk<System.IO.Stream?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetFilesThumbnailPathApiResponse"/>
    /// </summary>
    public interface IGetFilesThumbnailPathApiResponse : HydrusAPI.NET.Client.IApiResponse, IOk<HydrusAPI.NET.Model.GetFilesThumbnailPath200Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetLocalFileStorageLocationsApiResponse"/>
    /// </summary>
    public interface IGetLocalFileStorageLocationsApiResponse : HydrusAPI.NET.Client.IApiResponse, IOk<HydrusAPI.NET.Model.GetLocalFileStorageLocations200Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class GetFilesApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetFilesFile;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetFilesFile;

        internal void ExecuteOnGetFilesFile(GetFilesApi.GetFilesFileApiResponse apiResponse)
        {
            OnGetFilesFile?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetFilesFile(Exception exception)
        {
            OnErrorGetFilesFile?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetFilesFileHashes;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetFilesFileHashes;

        internal void ExecuteOnGetFilesFileHashes(GetFilesApi.GetFilesFileHashesApiResponse apiResponse)
        {
            OnGetFilesFileHashes?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetFilesFileHashes(Exception exception)
        {
            OnErrorGetFilesFileHashes?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetFilesFileMetadata;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetFilesFileMetadata;

        internal void ExecuteOnGetFilesFileMetadata(GetFilesApi.GetFilesFileMetadataApiResponse apiResponse)
        {
            OnGetFilesFileMetadata?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetFilesFileMetadata(Exception exception)
        {
            OnErrorGetFilesFileMetadata?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetFilesFilePath;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetFilesFilePath;

        internal void ExecuteOnGetFilesFilePath(GetFilesApi.GetFilesFilePathApiResponse apiResponse)
        {
            OnGetFilesFilePath?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetFilesFilePath(Exception exception)
        {
            OnErrorGetFilesFilePath?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetFilesRender;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetFilesRender;

        internal void ExecuteOnGetFilesRender(GetFilesApi.GetFilesRenderApiResponse apiResponse)
        {
            OnGetFilesRender?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetFilesRender(Exception exception)
        {
            OnErrorGetFilesRender?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetFilesSearchFiles;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetFilesSearchFiles;

        internal void ExecuteOnGetFilesSearchFiles(GetFilesApi.GetFilesSearchFilesApiResponse apiResponse)
        {
            OnGetFilesSearchFiles?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetFilesSearchFiles(Exception exception)
        {
            OnErrorGetFilesSearchFiles?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetFilesThumbnail;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetFilesThumbnail;

        internal void ExecuteOnGetFilesThumbnail(GetFilesApi.GetFilesThumbnailApiResponse apiResponse)
        {
            OnGetFilesThumbnail?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetFilesThumbnail(Exception exception)
        {
            OnErrorGetFilesThumbnail?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetFilesThumbnailPath;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetFilesThumbnailPath;

        internal void ExecuteOnGetFilesThumbnailPath(GetFilesApi.GetFilesThumbnailPathApiResponse apiResponse)
        {
            OnGetFilesThumbnailPath?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetFilesThumbnailPath(Exception exception)
        {
            OnErrorGetFilesThumbnailPath?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetLocalFileStorageLocations;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetLocalFileStorageLocations;

        internal void ExecuteOnGetLocalFileStorageLocations(GetFilesApi.GetLocalFileStorageLocationsApiResponse apiResponse)
        {
            OnGetLocalFileStorageLocations?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetLocalFileStorageLocations(Exception exception)
        {
            OnErrorGetLocalFileStorageLocations?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class GetFilesApi : IGetFilesApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<GetFilesApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public GetFilesApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="GetFilesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public GetFilesApi(ILogger<GetFilesApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, GetFilesApiEvents getFilesApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<GetFilesApi>();
            HttpClient = httpClient;
            Events = getFilesApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatGetFilesFile(ref Option<int> fileId, ref Option<string> hash, ref Option<bool> download);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="hash"></param>
        /// <returns></returns>
        private void ValidateGetFilesFile(Option<string> hash)
        {
            if (hash.IsSet && hash.Value == null)
                throw new ArgumentNullException(nameof(hash));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="hash"></param>
        /// <param name="download"></param>
        private void AfterGetFilesFileDefaultImplementation(IGetFilesFileApiResponse apiResponseLocalVar, Option<int> fileId, Option<string> hash, Option<bool> download)
        {
            bool suppressDefaultLog = false;
            AfterGetFilesFile(ref suppressDefaultLog, apiResponseLocalVar, fileId, hash, download);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="hash"></param>
        /// <param name="download"></param>
        partial void AfterGetFilesFile(ref bool suppressDefaultLog, IGetFilesFileApiResponse apiResponseLocalVar, Option<int> fileId, Option<string> hash, Option<bool> download);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="hash"></param>
        /// <param name="download"></param>
        private void OnErrorGetFilesFileDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> fileId, Option<string> hash, Option<bool> download)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetFilesFile(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, fileId, hash, download);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="hash"></param>
        /// <param name="download"></param>
        partial void OnErrorGetFilesFile(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> fileId, Option<string> hash, Option<bool> download);

        /// <summary>
        /// Get a file Retrieves a file based on &#x60;file_id&#x60; or &#x60;hash&#x60;. Requires appropriate access permissions.
        /// </summary>
        /// <param name="fileId">Numerical file ID for the file. (optional)</param>
        /// <param name="hash">Hexadecimal SHA256 hash for the file. Can only be used if the user has access to all files. (optional)</param>
        /// <param name="download">If true, sets &#x60;Content-Disposition&#x60; to &#x60;attachment&#x60;, prompting a download in browsers. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesFileApiResponse"/>&gt;</returns>
        public async Task<IGetFilesFileApiResponse?> GetFilesFileOrDefaultAsync(Option<int> fileId = default, Option<string> hash = default, Option<bool> download = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetFilesFileAsync(fileId, hash, download, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get a file Retrieves a file based on &#x60;file_id&#x60; or &#x60;hash&#x60;. Requires appropriate access permissions.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileId">Numerical file ID for the file. (optional)</param>
        /// <param name="hash">Hexadecimal SHA256 hash for the file. Can only be used if the user has access to all files. (optional)</param>
        /// <param name="download">If true, sets &#x60;Content-Disposition&#x60; to &#x60;attachment&#x60;, prompting a download in browsers. (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesFileApiResponse"/>&gt;</returns>
        public async Task<IGetFilesFileApiResponse> GetFilesFileAsync(Option<int> fileId = default, Option<string> hash = default, Option<bool> download = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetFilesFile(hash);

                FormatGetFilesFile(ref fileId, ref hash, ref download);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/get_files/file"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/get_files/file");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (fileId.IsSet)
                        parseQueryStringLocalVar["file_id"] = ClientUtils.ParameterToString(fileId.Value);

                    if (hash.IsSet)
                        parseQueryStringLocalVar["hash"] = ClientUtils.ParameterToString(hash.Value);

                    if (download.IsSet)
                        parseQueryStringLocalVar["download"] = ClientUtils.ParameterToString(download.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Access-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Session-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "*/*"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetFilesFileApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetFilesFileApiResponse>();
                        GetFilesFileApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            case (200):
                            {
                                byte[] responseBytesArrayLocalVar = await httpResponseMessageLocalVar.Content.ReadAsByteArrayAsync(cancellationToken).ConfigureAwait(false);
                                System.IO.Stream responseContentStreamLocalVar = new System.IO.MemoryStream(responseBytesArrayLocalVar);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentStreamLocalVar, "/get_files/file", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/get_files/file", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetFilesFileDefaultImplementation(apiResponseLocalVar, fileId, hash, download);

                        Events.ExecuteOnGetFilesFile(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetFilesFileDefaultImplementation(e, "/get_files/file", uriBuilderLocalVar.Path, fileId, hash, download);
                Events.ExecuteOnErrorGetFilesFile(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetFilesFileApiResponse"/>
        /// </summary>
        public partial class GetFilesFileApiResponse : HydrusAPI.NET.Client.ApiResponse, IGetFilesFileApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetFilesFileApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetFilesFileApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFilesFileApiResponse(ILogger<GetFilesFileApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetFilesFileApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFilesFileApiResponse(ILogger<GetFilesFileApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public System.IO.Stream? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? ContentStream
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out System.IO.Stream? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 419 CustomHttpStatusCode419
            /// </summary>
            /// <returns></returns>
            public bool IsCustomHttpStatusCode419 => 419 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetFilesFileHashes(ref string desiredHashType, ref Option<string> hash, Option<List<string>> hashes, ref Option<string> sourceHashType);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="desiredHashType"></param>
        /// <param name="hash"></param>
        /// <param name="hashes"></param>
        /// <param name="sourceHashType"></param>
        /// <returns></returns>
        private void ValidateGetFilesFileHashes(string desiredHashType, Option<string> hash, Option<List<string>> hashes, Option<string> sourceHashType)
        {
            if (desiredHashType == null)
                throw new ArgumentNullException(nameof(desiredHashType));

            if (hash.IsSet && hash.Value == null)
                throw new ArgumentNullException(nameof(hash));

            if (hashes.IsSet && hashes.Value == null)
                throw new ArgumentNullException(nameof(hashes));

            if (sourceHashType.IsSet && sourceHashType.Value == null)
                throw new ArgumentNullException(nameof(sourceHashType));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="desiredHashType"></param>
        /// <param name="hash"></param>
        /// <param name="hashes"></param>
        /// <param name="sourceHashType"></param>
        private void AfterGetFilesFileHashesDefaultImplementation(IGetFilesFileHashesApiResponse apiResponseLocalVar, string desiredHashType, Option<string> hash, Option<List<string>> hashes, Option<string> sourceHashType)
        {
            bool suppressDefaultLog = false;
            AfterGetFilesFileHashes(ref suppressDefaultLog, apiResponseLocalVar, desiredHashType, hash, hashes, sourceHashType);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="desiredHashType"></param>
        /// <param name="hash"></param>
        /// <param name="hashes"></param>
        /// <param name="sourceHashType"></param>
        partial void AfterGetFilesFileHashes(ref bool suppressDefaultLog, IGetFilesFileHashesApiResponse apiResponseLocalVar, string desiredHashType, Option<string> hash, Option<List<string>> hashes, Option<string> sourceHashType);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="desiredHashType"></param>
        /// <param name="hash"></param>
        /// <param name="hashes"></param>
        /// <param name="sourceHashType"></param>
        private void OnErrorGetFilesFileHashesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string desiredHashType, Option<string> hash, Option<List<string>> hashes, Option<string> sourceHashType)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetFilesFileHashes(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, desiredHashType, hash, hashes, sourceHashType);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="desiredHashType"></param>
        /// <param name="hash"></param>
        /// <param name="hashes"></param>
        /// <param name="sourceHashType"></param>
        partial void OnErrorGetFilesFileHashes(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string desiredHashType, Option<string> hash, Option<List<string>> hashes, Option<string> sourceHashType);

        /// <summary>
        /// Lookup file hashes from other hashes Converts hashes between types (e.g., MD5 to SHA256)
        /// </summary>
        /// <param name="desiredHashType"></param>
        /// <param name="hash"> (optional)</param>
        /// <param name="hashes"> (optional)</param>
        /// <param name="sourceHashType"> (optional, default to sha256)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesFileHashesApiResponse"/>&gt;</returns>
        public async Task<IGetFilesFileHashesApiResponse?> GetFilesFileHashesOrDefaultAsync(string desiredHashType, Option<string> hash = default, Option<List<string>> hashes = default, Option<string> sourceHashType = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetFilesFileHashesAsync(desiredHashType, hash, hashes, sourceHashType, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Lookup file hashes from other hashes Converts hashes between types (e.g., MD5 to SHA256)
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="desiredHashType"></param>
        /// <param name="hash"> (optional)</param>
        /// <param name="hashes"> (optional)</param>
        /// <param name="sourceHashType"> (optional, default to sha256)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesFileHashesApiResponse"/>&gt;</returns>
        public async Task<IGetFilesFileHashesApiResponse> GetFilesFileHashesAsync(string desiredHashType, Option<string> hash = default, Option<List<string>> hashes = default, Option<string> sourceHashType = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetFilesFileHashes(desiredHashType, hash, hashes, sourceHashType);

                FormatGetFilesFileHashes(ref desiredHashType, ref hash, hashes, ref sourceHashType);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/get_files/file_hashes"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/get_files/file_hashes");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["desired_hash_type"] = ClientUtils.ParameterToString(desiredHashType);

                    if (hash.IsSet)
                        parseQueryStringLocalVar["hash"] = ClientUtils.ParameterToString(hash.Value);

                    if (hashes.IsSet)
                        parseQueryStringLocalVar["hashes"] = ClientUtils.ParameterToString(hashes.Value);

                    if (sourceHashType.IsSet)
                        parseQueryStringLocalVar["source_hash_type"] = ClientUtils.ParameterToString(sourceHashType.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Access-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Session-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetFilesFileHashesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetFilesFileHashesApiResponse>();
                        GetFilesFileHashesApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/get_files/file_hashes", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetFilesFileHashesDefaultImplementation(apiResponseLocalVar, desiredHashType, hash, hashes, sourceHashType);

                        Events.ExecuteOnGetFilesFileHashes(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetFilesFileHashesDefaultImplementation(e, "/get_files/file_hashes", uriBuilderLocalVar.Path, desiredHashType, hash, hashes, sourceHashType);
                Events.ExecuteOnErrorGetFilesFileHashes(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetFilesFileHashesApiResponse"/>
        /// </summary>
        public partial class GetFilesFileHashesApiResponse : HydrusAPI.NET.Client.ApiResponse, IGetFilesFileHashesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetFilesFileHashesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetFilesFileHashesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFilesFileHashesApiResponse(ILogger<GetFilesFileHashesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetFilesFileHashesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFilesFileHashesApiResponse(ILogger<GetFilesFileHashesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public HydrusAPI.NET.Model.GetFilesFileHashes200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<HydrusAPI.NET.Model.GetFilesFileHashes200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out HydrusAPI.NET.Model.GetFilesFileHashes200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 419 CustomHttpStatusCode419
            /// </summary>
            /// <returns></returns>
            public bool IsCustomHttpStatusCode419 => 419 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetFilesFileMetadata(ref Option<int> fileId, Option<List<int>> fileIds, ref Option<string> hash, Option<List<string>> hashes, ref Option<bool> createNewFileIds, ref Option<bool> onlyReturnIdentifiers, ref Option<bool> onlyReturnBasicInformation, ref Option<bool> detailedUrlInformation, ref Option<bool> includeBlurhash, ref Option<bool> includeMilliseconds, ref Option<bool> includeNotes, ref Option<bool> includeServicesObject, ref Option<bool> hideServiceKeysTags);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="fileIds"></param>
        /// <param name="hash"></param>
        /// <param name="hashes"></param>
        /// <returns></returns>
        private void ValidateGetFilesFileMetadata(Option<List<int>> fileIds, Option<string> hash, Option<List<string>> hashes)
        {
            if (fileIds.IsSet && fileIds.Value == null)
                throw new ArgumentNullException(nameof(fileIds));

            if (hash.IsSet && hash.Value == null)
                throw new ArgumentNullException(nameof(hash));

            if (hashes.IsSet && hashes.Value == null)
                throw new ArgumentNullException(nameof(hashes));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="fileIds"></param>
        /// <param name="hash"></param>
        /// <param name="hashes"></param>
        /// <param name="createNewFileIds"></param>
        /// <param name="onlyReturnIdentifiers"></param>
        /// <param name="onlyReturnBasicInformation"></param>
        /// <param name="detailedUrlInformation"></param>
        /// <param name="includeBlurhash"></param>
        /// <param name="includeMilliseconds"></param>
        /// <param name="includeNotes"></param>
        /// <param name="includeServicesObject"></param>
        /// <param name="hideServiceKeysTags"></param>
        private void AfterGetFilesFileMetadataDefaultImplementation(IGetFilesFileMetadataApiResponse apiResponseLocalVar, Option<int> fileId, Option<List<int>> fileIds, Option<string> hash, Option<List<string>> hashes, Option<bool> createNewFileIds, Option<bool> onlyReturnIdentifiers, Option<bool> onlyReturnBasicInformation, Option<bool> detailedUrlInformation, Option<bool> includeBlurhash, Option<bool> includeMilliseconds, Option<bool> includeNotes, Option<bool> includeServicesObject, Option<bool> hideServiceKeysTags)
        {
            bool suppressDefaultLog = false;
            AfterGetFilesFileMetadata(ref suppressDefaultLog, apiResponseLocalVar, fileId, fileIds, hash, hashes, createNewFileIds, onlyReturnIdentifiers, onlyReturnBasicInformation, detailedUrlInformation, includeBlurhash, includeMilliseconds, includeNotes, includeServicesObject, hideServiceKeysTags);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="fileIds"></param>
        /// <param name="hash"></param>
        /// <param name="hashes"></param>
        /// <param name="createNewFileIds"></param>
        /// <param name="onlyReturnIdentifiers"></param>
        /// <param name="onlyReturnBasicInformation"></param>
        /// <param name="detailedUrlInformation"></param>
        /// <param name="includeBlurhash"></param>
        /// <param name="includeMilliseconds"></param>
        /// <param name="includeNotes"></param>
        /// <param name="includeServicesObject"></param>
        /// <param name="hideServiceKeysTags"></param>
        partial void AfterGetFilesFileMetadata(ref bool suppressDefaultLog, IGetFilesFileMetadataApiResponse apiResponseLocalVar, Option<int> fileId, Option<List<int>> fileIds, Option<string> hash, Option<List<string>> hashes, Option<bool> createNewFileIds, Option<bool> onlyReturnIdentifiers, Option<bool> onlyReturnBasicInformation, Option<bool> detailedUrlInformation, Option<bool> includeBlurhash, Option<bool> includeMilliseconds, Option<bool> includeNotes, Option<bool> includeServicesObject, Option<bool> hideServiceKeysTags);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="fileIds"></param>
        /// <param name="hash"></param>
        /// <param name="hashes"></param>
        /// <param name="createNewFileIds"></param>
        /// <param name="onlyReturnIdentifiers"></param>
        /// <param name="onlyReturnBasicInformation"></param>
        /// <param name="detailedUrlInformation"></param>
        /// <param name="includeBlurhash"></param>
        /// <param name="includeMilliseconds"></param>
        /// <param name="includeNotes"></param>
        /// <param name="includeServicesObject"></param>
        /// <param name="hideServiceKeysTags"></param>
        private void OnErrorGetFilesFileMetadataDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> fileId, Option<List<int>> fileIds, Option<string> hash, Option<List<string>> hashes, Option<bool> createNewFileIds, Option<bool> onlyReturnIdentifiers, Option<bool> onlyReturnBasicInformation, Option<bool> detailedUrlInformation, Option<bool> includeBlurhash, Option<bool> includeMilliseconds, Option<bool> includeNotes, Option<bool> includeServicesObject, Option<bool> hideServiceKeysTags)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetFilesFileMetadata(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, fileId, fileIds, hash, hashes, createNewFileIds, onlyReturnIdentifiers, onlyReturnBasicInformation, detailedUrlInformation, includeBlurhash, includeMilliseconds, includeNotes, includeServicesObject, hideServiceKeysTags);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="fileIds"></param>
        /// <param name="hash"></param>
        /// <param name="hashes"></param>
        /// <param name="createNewFileIds"></param>
        /// <param name="onlyReturnIdentifiers"></param>
        /// <param name="onlyReturnBasicInformation"></param>
        /// <param name="detailedUrlInformation"></param>
        /// <param name="includeBlurhash"></param>
        /// <param name="includeMilliseconds"></param>
        /// <param name="includeNotes"></param>
        /// <param name="includeServicesObject"></param>
        /// <param name="hideServiceKeysTags"></param>
        partial void OnErrorGetFilesFileMetadata(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> fileId, Option<List<int>> fileIds, Option<string> hash, Option<List<string>> hashes, Option<bool> createNewFileIds, Option<bool> onlyReturnIdentifiers, Option<bool> onlyReturnBasicInformation, Option<bool> detailedUrlInformation, Option<bool> includeBlurhash, Option<bool> includeMilliseconds, Option<bool> includeNotes, Option<bool> includeServicesObject, Option<bool> hideServiceKeysTags);

        /// <summary>
        /// Get metadata about files in the client 
        /// </summary>
        /// <param name="fileId"> (optional)</param>
        /// <param name="fileIds"> (optional)</param>
        /// <param name="hash"> (optional)</param>
        /// <param name="hashes"> (optional)</param>
        /// <param name="createNewFileIds"> (optional)</param>
        /// <param name="onlyReturnIdentifiers"> (optional)</param>
        /// <param name="onlyReturnBasicInformation"> (optional)</param>
        /// <param name="detailedUrlInformation"> (optional)</param>
        /// <param name="includeBlurhash"> (optional)</param>
        /// <param name="includeMilliseconds"> (optional)</param>
        /// <param name="includeNotes"> (optional)</param>
        /// <param name="includeServicesObject"> (optional)</param>
        /// <param name="hideServiceKeysTags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesFileMetadataApiResponse"/>&gt;</returns>
        public async Task<IGetFilesFileMetadataApiResponse?> GetFilesFileMetadataOrDefaultAsync(Option<int> fileId = default, Option<List<int>> fileIds = default, Option<string> hash = default, Option<List<string>> hashes = default, Option<bool> createNewFileIds = default, Option<bool> onlyReturnIdentifiers = default, Option<bool> onlyReturnBasicInformation = default, Option<bool> detailedUrlInformation = default, Option<bool> includeBlurhash = default, Option<bool> includeMilliseconds = default, Option<bool> includeNotes = default, Option<bool> includeServicesObject = default, Option<bool> hideServiceKeysTags = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetFilesFileMetadataAsync(fileId, fileIds, hash, hashes, createNewFileIds, onlyReturnIdentifiers, onlyReturnBasicInformation, detailedUrlInformation, includeBlurhash, includeMilliseconds, includeNotes, includeServicesObject, hideServiceKeysTags, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get metadata about files in the client 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileId"> (optional)</param>
        /// <param name="fileIds"> (optional)</param>
        /// <param name="hash"> (optional)</param>
        /// <param name="hashes"> (optional)</param>
        /// <param name="createNewFileIds"> (optional)</param>
        /// <param name="onlyReturnIdentifiers"> (optional)</param>
        /// <param name="onlyReturnBasicInformation"> (optional)</param>
        /// <param name="detailedUrlInformation"> (optional)</param>
        /// <param name="includeBlurhash"> (optional)</param>
        /// <param name="includeMilliseconds"> (optional)</param>
        /// <param name="includeNotes"> (optional)</param>
        /// <param name="includeServicesObject"> (optional)</param>
        /// <param name="hideServiceKeysTags"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesFileMetadataApiResponse"/>&gt;</returns>
        public async Task<IGetFilesFileMetadataApiResponse> GetFilesFileMetadataAsync(Option<int> fileId = default, Option<List<int>> fileIds = default, Option<string> hash = default, Option<List<string>> hashes = default, Option<bool> createNewFileIds = default, Option<bool> onlyReturnIdentifiers = default, Option<bool> onlyReturnBasicInformation = default, Option<bool> detailedUrlInformation = default, Option<bool> includeBlurhash = default, Option<bool> includeMilliseconds = default, Option<bool> includeNotes = default, Option<bool> includeServicesObject = default, Option<bool> hideServiceKeysTags = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetFilesFileMetadata(fileIds, hash, hashes);

                FormatGetFilesFileMetadata(ref fileId, fileIds, ref hash, hashes, ref createNewFileIds, ref onlyReturnIdentifiers, ref onlyReturnBasicInformation, ref detailedUrlInformation, ref includeBlurhash, ref includeMilliseconds, ref includeNotes, ref includeServicesObject, ref hideServiceKeysTags);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/get_files/file_metadata"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/get_files/file_metadata");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (fileId.IsSet)
                        parseQueryStringLocalVar["file_id"] = ClientUtils.ParameterToString(fileId.Value);

                    if (fileIds.IsSet)
                        parseQueryStringLocalVar["file_ids"] = ClientUtils.ParameterToString(fileIds.Value);

                    if (hash.IsSet)
                        parseQueryStringLocalVar["hash"] = ClientUtils.ParameterToString(hash.Value);

                    if (hashes.IsSet)
                        parseQueryStringLocalVar["hashes"] = ClientUtils.ParameterToString(hashes.Value);

                    if (createNewFileIds.IsSet)
                        parseQueryStringLocalVar["create_new_file_ids"] = ClientUtils.ParameterToString(createNewFileIds.Value);

                    if (onlyReturnIdentifiers.IsSet)
                        parseQueryStringLocalVar["only_return_identifiers"] = ClientUtils.ParameterToString(onlyReturnIdentifiers.Value);

                    if (onlyReturnBasicInformation.IsSet)
                        parseQueryStringLocalVar["only_return_basic_information"] = ClientUtils.ParameterToString(onlyReturnBasicInformation.Value);

                    if (detailedUrlInformation.IsSet)
                        parseQueryStringLocalVar["detailed_url_information"] = ClientUtils.ParameterToString(detailedUrlInformation.Value);

                    if (includeBlurhash.IsSet)
                        parseQueryStringLocalVar["include_blurhash"] = ClientUtils.ParameterToString(includeBlurhash.Value);

                    if (includeMilliseconds.IsSet)
                        parseQueryStringLocalVar["include_milliseconds"] = ClientUtils.ParameterToString(includeMilliseconds.Value);

                    if (includeNotes.IsSet)
                        parseQueryStringLocalVar["include_notes"] = ClientUtils.ParameterToString(includeNotes.Value);

                    if (includeServicesObject.IsSet)
                        parseQueryStringLocalVar["include_services_object"] = ClientUtils.ParameterToString(includeServicesObject.Value);

                    if (hideServiceKeysTags.IsSet)
                        parseQueryStringLocalVar["hide_service_keys_tags"] = ClientUtils.ParameterToString(hideServiceKeysTags.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Access-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Session-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetFilesFileMetadataApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetFilesFileMetadataApiResponse>();
                        GetFilesFileMetadataApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/get_files/file_metadata", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetFilesFileMetadataDefaultImplementation(apiResponseLocalVar, fileId, fileIds, hash, hashes, createNewFileIds, onlyReturnIdentifiers, onlyReturnBasicInformation, detailedUrlInformation, includeBlurhash, includeMilliseconds, includeNotes, includeServicesObject, hideServiceKeysTags);

                        Events.ExecuteOnGetFilesFileMetadata(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetFilesFileMetadataDefaultImplementation(e, "/get_files/file_metadata", uriBuilderLocalVar.Path, fileId, fileIds, hash, hashes, createNewFileIds, onlyReturnIdentifiers, onlyReturnBasicInformation, detailedUrlInformation, includeBlurhash, includeMilliseconds, includeNotes, includeServicesObject, hideServiceKeysTags);
                Events.ExecuteOnErrorGetFilesFileMetadata(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetFilesFileMetadataApiResponse"/>
        /// </summary>
        public partial class GetFilesFileMetadataApiResponse : HydrusAPI.NET.Client.ApiResponse, IGetFilesFileMetadataApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetFilesFileMetadataApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetFilesFileMetadataApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFilesFileMetadataApiResponse(ILogger<GetFilesFileMetadataApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetFilesFileMetadataApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFilesFileMetadataApiResponse(ILogger<GetFilesFileMetadataApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public HydrusAPI.NET.Model.GetFilesFileMetadata200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<HydrusAPI.NET.Model.GetFilesFileMetadata200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out HydrusAPI.NET.Model.GetFilesFileMetadata200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetFilesFilePath(ref Option<int> fileId, ref Option<string> hash);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="hash"></param>
        /// <returns></returns>
        private void ValidateGetFilesFilePath(Option<string> hash)
        {
            if (hash.IsSet && hash.Value == null)
                throw new ArgumentNullException(nameof(hash));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="hash"></param>
        private void AfterGetFilesFilePathDefaultImplementation(IGetFilesFilePathApiResponse apiResponseLocalVar, Option<int> fileId, Option<string> hash)
        {
            bool suppressDefaultLog = false;
            AfterGetFilesFilePath(ref suppressDefaultLog, apiResponseLocalVar, fileId, hash);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="hash"></param>
        partial void AfterGetFilesFilePath(ref bool suppressDefaultLog, IGetFilesFilePathApiResponse apiResponseLocalVar, Option<int> fileId, Option<string> hash);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="hash"></param>
        private void OnErrorGetFilesFilePathDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> fileId, Option<string> hash)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetFilesFilePath(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, fileId, hash);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="hash"></param>
        partial void OnErrorGetFilesFilePath(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> fileId, Option<string> hash);

        /// <summary>
        /// Get the local file path and metadata. Retrieves the local file system path, filetype, and size for a specified file either by &#x60;file_id&#x60; or &#x60;hash&#x60;.
        /// </summary>
        /// <param name="fileId"> (optional)</param>
        /// <param name="hash"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesFilePathApiResponse"/>&gt;</returns>
        public async Task<IGetFilesFilePathApiResponse?> GetFilesFilePathOrDefaultAsync(Option<int> fileId = default, Option<string> hash = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetFilesFilePathAsync(fileId, hash, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get the local file path and metadata. Retrieves the local file system path, filetype, and size for a specified file either by &#x60;file_id&#x60; or &#x60;hash&#x60;.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileId"> (optional)</param>
        /// <param name="hash"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesFilePathApiResponse"/>&gt;</returns>
        public async Task<IGetFilesFilePathApiResponse> GetFilesFilePathAsync(Option<int> fileId = default, Option<string> hash = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetFilesFilePath(hash);

                FormatGetFilesFilePath(ref fileId, ref hash);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/get_files/file_path"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/get_files/file_path");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (fileId.IsSet)
                        parseQueryStringLocalVar["file_id"] = ClientUtils.ParameterToString(fileId.Value);

                    if (hash.IsSet)
                        parseQueryStringLocalVar["hash"] = ClientUtils.ParameterToString(hash.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Access-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Session-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetFilesFilePathApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetFilesFilePathApiResponse>();
                        GetFilesFilePathApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/get_files/file_path", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetFilesFilePathDefaultImplementation(apiResponseLocalVar, fileId, hash);

                        Events.ExecuteOnGetFilesFilePath(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetFilesFilePathDefaultImplementation(e, "/get_files/file_path", uriBuilderLocalVar.Path, fileId, hash);
                Events.ExecuteOnErrorGetFilesFilePath(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetFilesFilePathApiResponse"/>
        /// </summary>
        public partial class GetFilesFilePathApiResponse : HydrusAPI.NET.Client.ApiResponse, IGetFilesFilePathApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetFilesFilePathApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetFilesFilePathApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFilesFilePathApiResponse(ILogger<GetFilesFilePathApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetFilesFilePathApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFilesFilePathApiResponse(ILogger<GetFilesFilePathApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public HydrusAPI.NET.Model.GetFilesFilePath200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<HydrusAPI.NET.Model.GetFilesFilePath200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out HydrusAPI.NET.Model.GetFilesFilePath200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetFilesRender(ref Option<int> fileId, ref Option<string> hash, ref Option<bool> download, ref Option<int> renderFormat, ref Option<int> renderQuality, ref Option<int> width, ref Option<int> height);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="hash"></param>
        /// <returns></returns>
        private void ValidateGetFilesRender(Option<string> hash)
        {
            if (hash.IsSet && hash.Value == null)
                throw new ArgumentNullException(nameof(hash));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="hash"></param>
        /// <param name="download"></param>
        /// <param name="renderFormat"></param>
        /// <param name="renderQuality"></param>
        /// <param name="width"></param>
        /// <param name="height"></param>
        private void AfterGetFilesRenderDefaultImplementation(IGetFilesRenderApiResponse apiResponseLocalVar, Option<int> fileId, Option<string> hash, Option<bool> download, Option<int> renderFormat, Option<int> renderQuality, Option<int> width, Option<int> height)
        {
            bool suppressDefaultLog = false;
            AfterGetFilesRender(ref suppressDefaultLog, apiResponseLocalVar, fileId, hash, download, renderFormat, renderQuality, width, height);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="hash"></param>
        /// <param name="download"></param>
        /// <param name="renderFormat"></param>
        /// <param name="renderQuality"></param>
        /// <param name="width"></param>
        /// <param name="height"></param>
        partial void AfterGetFilesRender(ref bool suppressDefaultLog, IGetFilesRenderApiResponse apiResponseLocalVar, Option<int> fileId, Option<string> hash, Option<bool> download, Option<int> renderFormat, Option<int> renderQuality, Option<int> width, Option<int> height);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="hash"></param>
        /// <param name="download"></param>
        /// <param name="renderFormat"></param>
        /// <param name="renderQuality"></param>
        /// <param name="width"></param>
        /// <param name="height"></param>
        private void OnErrorGetFilesRenderDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> fileId, Option<string> hash, Option<bool> download, Option<int> renderFormat, Option<int> renderQuality, Option<int> width, Option<int> height)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetFilesRender(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, fileId, hash, download, renderFormat, renderQuality, width, height);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="hash"></param>
        /// <param name="download"></param>
        /// <param name="renderFormat"></param>
        /// <param name="renderQuality"></param>
        /// <param name="width"></param>
        /// <param name="height"></param>
        partial void OnErrorGetFilesRender(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> fileId, Option<string> hash, Option<bool> download, Option<int> renderFormat, Option<int> renderQuality, Option<int> width, Option<int> height);

        /// <summary>
        /// Get an image or ugoira file as rendered by Hydrus Retrieves a file (image or ugoira) rendered by Hydrus, optionally resized or converted to a specific format.
        /// </summary>
        /// <param name="fileId"> (optional)</param>
        /// <param name="hash"> (optional)</param>
        /// <param name="download"> (optional, default to false)</param>
        /// <param name="renderFormat"> (optional)</param>
        /// <param name="renderQuality"> (optional)</param>
        /// <param name="width"> (optional)</param>
        /// <param name="height"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesRenderApiResponse"/>&gt;</returns>
        public async Task<IGetFilesRenderApiResponse?> GetFilesRenderOrDefaultAsync(Option<int> fileId = default, Option<string> hash = default, Option<bool> download = default, Option<int> renderFormat = default, Option<int> renderQuality = default, Option<int> width = default, Option<int> height = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetFilesRenderAsync(fileId, hash, download, renderFormat, renderQuality, width, height, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get an image or ugoira file as rendered by Hydrus Retrieves a file (image or ugoira) rendered by Hydrus, optionally resized or converted to a specific format.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileId"> (optional)</param>
        /// <param name="hash"> (optional)</param>
        /// <param name="download"> (optional, default to false)</param>
        /// <param name="renderFormat"> (optional)</param>
        /// <param name="renderQuality"> (optional)</param>
        /// <param name="width"> (optional)</param>
        /// <param name="height"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesRenderApiResponse"/>&gt;</returns>
        public async Task<IGetFilesRenderApiResponse> GetFilesRenderAsync(Option<int> fileId = default, Option<string> hash = default, Option<bool> download = default, Option<int> renderFormat = default, Option<int> renderQuality = default, Option<int> width = default, Option<int> height = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetFilesRender(hash);

                FormatGetFilesRender(ref fileId, ref hash, ref download, ref renderFormat, ref renderQuality, ref width, ref height);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/get_files/render"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/get_files/render");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (fileId.IsSet)
                        parseQueryStringLocalVar["file_id"] = ClientUtils.ParameterToString(fileId.Value);

                    if (hash.IsSet)
                        parseQueryStringLocalVar["hash"] = ClientUtils.ParameterToString(hash.Value);

                    if (download.IsSet)
                        parseQueryStringLocalVar["download"] = ClientUtils.ParameterToString(download.Value);

                    if (renderFormat.IsSet)
                        parseQueryStringLocalVar["render_format"] = ClientUtils.ParameterToString(renderFormat.Value);

                    if (renderQuality.IsSet)
                        parseQueryStringLocalVar["render_quality"] = ClientUtils.ParameterToString(renderQuality.Value);

                    if (width.IsSet)
                        parseQueryStringLocalVar["width"] = ClientUtils.ParameterToString(width.Value);

                    if (height.IsSet)
                        parseQueryStringLocalVar["height"] = ClientUtils.ParameterToString(height.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Access-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Session-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "image/png",
                        "image/jpeg",
                        "image/webp",
                        "image/apng"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetFilesRenderApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetFilesRenderApiResponse>();
                        GetFilesRenderApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            case (200):
                            {
                                byte[] responseBytesArrayLocalVar = await httpResponseMessageLocalVar.Content.ReadAsByteArrayAsync(cancellationToken).ConfigureAwait(false);
                                System.IO.Stream responseContentStreamLocalVar = new System.IO.MemoryStream(responseBytesArrayLocalVar);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentStreamLocalVar, "/get_files/render", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/get_files/render", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetFilesRenderDefaultImplementation(apiResponseLocalVar, fileId, hash, download, renderFormat, renderQuality, width, height);

                        Events.ExecuteOnGetFilesRender(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetFilesRenderDefaultImplementation(e, "/get_files/render", uriBuilderLocalVar.Path, fileId, hash, download, renderFormat, renderQuality, width, height);
                Events.ExecuteOnErrorGetFilesRender(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetFilesRenderApiResponse"/>
        /// </summary>
        public partial class GetFilesRenderApiResponse : HydrusAPI.NET.Client.ApiResponse, IGetFilesRenderApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetFilesRenderApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetFilesRenderApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFilesRenderApiResponse(ILogger<GetFilesRenderApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetFilesRenderApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFilesRenderApiResponse(ILogger<GetFilesRenderApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public System.IO.Stream? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? ContentStream
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out System.IO.Stream? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 419 CustomHttpStatusCode419
            /// </summary>
            /// <returns></returns>
            public bool IsCustomHttpStatusCode419 => 419 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetFilesSearchFiles(List<string> tags, ref Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, ref Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, ref Option<string> tagServiceKey, ref Option<bool> includeCurrentTags, ref Option<bool> includePendingTags, ref Option<int> fileSortType, ref Option<bool> fileSortAsc, ref Option<bool> returnFileIds, ref Option<bool> returnHashes);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="tags"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey"></param>
        /// <returns></returns>
        private void ValidateGetFilesSearchFiles(List<string> tags, Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey)
        {
            if (tags == null)
                throw new ArgumentNullException(nameof(tags));

            if (fileServiceKey.IsSet && fileServiceKey.Value == null)
                throw new ArgumentNullException(nameof(fileServiceKey));

            if (fileServiceKeys.IsSet && fileServiceKeys.Value == null)
                throw new ArgumentNullException(nameof(fileServiceKeys));

            if (deletedFileServiceKey.IsSet && deletedFileServiceKey.Value == null)
                throw new ArgumentNullException(nameof(deletedFileServiceKey));

            if (deletedFileServiceKeys.IsSet && deletedFileServiceKeys.Value == null)
                throw new ArgumentNullException(nameof(deletedFileServiceKeys));

            if (tagServiceKey.IsSet && tagServiceKey.Value == null)
                throw new ArgumentNullException(nameof(tagServiceKey));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tags"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey"></param>
        /// <param name="includeCurrentTags"></param>
        /// <param name="includePendingTags"></param>
        /// <param name="fileSortType"></param>
        /// <param name="fileSortAsc"></param>
        /// <param name="returnFileIds"></param>
        /// <param name="returnHashes"></param>
        private void AfterGetFilesSearchFilesDefaultImplementation(IGetFilesSearchFilesApiResponse apiResponseLocalVar, List<string> tags, Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey, Option<bool> includeCurrentTags, Option<bool> includePendingTags, Option<int> fileSortType, Option<bool> fileSortAsc, Option<bool> returnFileIds, Option<bool> returnHashes)
        {
            bool suppressDefaultLog = false;
            AfterGetFilesSearchFiles(ref suppressDefaultLog, apiResponseLocalVar, tags, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey, includeCurrentTags, includePendingTags, fileSortType, fileSortAsc, returnFileIds, returnHashes);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="tags"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey"></param>
        /// <param name="includeCurrentTags"></param>
        /// <param name="includePendingTags"></param>
        /// <param name="fileSortType"></param>
        /// <param name="fileSortAsc"></param>
        /// <param name="returnFileIds"></param>
        /// <param name="returnHashes"></param>
        partial void AfterGetFilesSearchFiles(ref bool suppressDefaultLog, IGetFilesSearchFilesApiResponse apiResponseLocalVar, List<string> tags, Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey, Option<bool> includeCurrentTags, Option<bool> includePendingTags, Option<int> fileSortType, Option<bool> fileSortAsc, Option<bool> returnFileIds, Option<bool> returnHashes);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="tags"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey"></param>
        /// <param name="includeCurrentTags"></param>
        /// <param name="includePendingTags"></param>
        /// <param name="fileSortType"></param>
        /// <param name="fileSortAsc"></param>
        /// <param name="returnFileIds"></param>
        /// <param name="returnHashes"></param>
        private void OnErrorGetFilesSearchFilesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<string> tags, Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey, Option<bool> includeCurrentTags, Option<bool> includePendingTags, Option<int> fileSortType, Option<bool> fileSortAsc, Option<bool> returnFileIds, Option<bool> returnHashes)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetFilesSearchFiles(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, tags, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey, includeCurrentTags, includePendingTags, fileSortType, fileSortAsc, returnFileIds, returnHashes);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="tags"></param>
        /// <param name="fileServiceKey"></param>
        /// <param name="fileServiceKeys"></param>
        /// <param name="deletedFileServiceKey"></param>
        /// <param name="deletedFileServiceKeys"></param>
        /// <param name="tagServiceKey"></param>
        /// <param name="includeCurrentTags"></param>
        /// <param name="includePendingTags"></param>
        /// <param name="fileSortType"></param>
        /// <param name="fileSortAsc"></param>
        /// <param name="returnFileIds"></param>
        /// <param name="returnHashes"></param>
        partial void OnErrorGetFilesSearchFiles(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<string> tags, Option<string> fileServiceKey, Option<List<string>> fileServiceKeys, Option<string> deletedFileServiceKey, Option<List<string>> deletedFileServiceKeys, Option<string> tagServiceKey, Option<bool> includeCurrentTags, Option<bool> includePendingTags, Option<int> fileSortType, Option<bool> fileSortAsc, Option<bool> returnFileIds, Option<bool> returnHashes);

        /// <summary>
        /// Search for the client&#39;s files. Search for files using tags and system predicates. Supports complex search logic including wildcards, negation, and system predicates like file size, resolution, and time filters.
        /// </summary>
        /// <param name="tags"></param>
        /// <param name="fileServiceKey"> (optional)</param>
        /// <param name="fileServiceKeys"> (optional)</param>
        /// <param name="deletedFileServiceKey"> (optional)</param>
        /// <param name="deletedFileServiceKeys"> (optional)</param>
        /// <param name="tagServiceKey"> (optional)</param>
        /// <param name="includeCurrentTags"> (optional, default to true)</param>
        /// <param name="includePendingTags"> (optional, default to true)</param>
        /// <param name="fileSortType"> (optional, default to 2)</param>
        /// <param name="fileSortAsc"> (optional, default to false)</param>
        /// <param name="returnFileIds"> (optional, default to true)</param>
        /// <param name="returnHashes"> (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesSearchFilesApiResponse"/>&gt;</returns>
        public async Task<IGetFilesSearchFilesApiResponse?> GetFilesSearchFilesOrDefaultAsync(List<string> tags, Option<string> fileServiceKey = default, Option<List<string>> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<List<string>> deletedFileServiceKeys = default, Option<string> tagServiceKey = default, Option<bool> includeCurrentTags = default, Option<bool> includePendingTags = default, Option<int> fileSortType = default, Option<bool> fileSortAsc = default, Option<bool> returnFileIds = default, Option<bool> returnHashes = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetFilesSearchFilesAsync(tags, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey, includeCurrentTags, includePendingTags, fileSortType, fileSortAsc, returnFileIds, returnHashes, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Search for the client&#39;s files. Search for files using tags and system predicates. Supports complex search logic including wildcards, negation, and system predicates like file size, resolution, and time filters.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="tags"></param>
        /// <param name="fileServiceKey"> (optional)</param>
        /// <param name="fileServiceKeys"> (optional)</param>
        /// <param name="deletedFileServiceKey"> (optional)</param>
        /// <param name="deletedFileServiceKeys"> (optional)</param>
        /// <param name="tagServiceKey"> (optional)</param>
        /// <param name="includeCurrentTags"> (optional, default to true)</param>
        /// <param name="includePendingTags"> (optional, default to true)</param>
        /// <param name="fileSortType"> (optional, default to 2)</param>
        /// <param name="fileSortAsc"> (optional, default to false)</param>
        /// <param name="returnFileIds"> (optional, default to true)</param>
        /// <param name="returnHashes"> (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesSearchFilesApiResponse"/>&gt;</returns>
        public async Task<IGetFilesSearchFilesApiResponse> GetFilesSearchFilesAsync(List<string> tags, Option<string> fileServiceKey = default, Option<List<string>> fileServiceKeys = default, Option<string> deletedFileServiceKey = default, Option<List<string>> deletedFileServiceKeys = default, Option<string> tagServiceKey = default, Option<bool> includeCurrentTags = default, Option<bool> includePendingTags = default, Option<int> fileSortType = default, Option<bool> fileSortAsc = default, Option<bool> returnFileIds = default, Option<bool> returnHashes = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetFilesSearchFiles(tags, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey);

                FormatGetFilesSearchFiles(tags, ref fileServiceKey, fileServiceKeys, ref deletedFileServiceKey, deletedFileServiceKeys, ref tagServiceKey, ref includeCurrentTags, ref includePendingTags, ref fileSortType, ref fileSortAsc, ref returnFileIds, ref returnHashes);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/get_files/search_files"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/get_files/search_files");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["tags"] = ClientUtils.ParameterToString(tags);

                    if (fileServiceKey.IsSet)
                        parseQueryStringLocalVar["file_service_key"] = ClientUtils.ParameterToString(fileServiceKey.Value);

                    if (fileServiceKeys.IsSet)
                        parseQueryStringLocalVar["file_service_keys"] = ClientUtils.ParameterToString(fileServiceKeys.Value);

                    if (deletedFileServiceKey.IsSet)
                        parseQueryStringLocalVar["deleted_file_service_key"] = ClientUtils.ParameterToString(deletedFileServiceKey.Value);

                    if (deletedFileServiceKeys.IsSet)
                        parseQueryStringLocalVar["deleted_file_service_keys"] = ClientUtils.ParameterToString(deletedFileServiceKeys.Value);

                    if (tagServiceKey.IsSet)
                        parseQueryStringLocalVar["tag_service_key"] = ClientUtils.ParameterToString(tagServiceKey.Value);

                    if (includeCurrentTags.IsSet)
                        parseQueryStringLocalVar["include_current_tags"] = ClientUtils.ParameterToString(includeCurrentTags.Value);

                    if (includePendingTags.IsSet)
                        parseQueryStringLocalVar["include_pending_tags"] = ClientUtils.ParameterToString(includePendingTags.Value);

                    if (fileSortType.IsSet)
                        parseQueryStringLocalVar["file_sort_type"] = ClientUtils.ParameterToString(fileSortType.Value);

                    if (fileSortAsc.IsSet)
                        parseQueryStringLocalVar["file_sort_asc"] = ClientUtils.ParameterToString(fileSortAsc.Value);

                    if (returnFileIds.IsSet)
                        parseQueryStringLocalVar["return_file_ids"] = ClientUtils.ParameterToString(returnFileIds.Value);

                    if (returnHashes.IsSet)
                        parseQueryStringLocalVar["return_hashes"] = ClientUtils.ParameterToString(returnHashes.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Access-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Session-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetFilesSearchFilesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetFilesSearchFilesApiResponse>();
                        GetFilesSearchFilesApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/get_files/search_files", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetFilesSearchFilesDefaultImplementation(apiResponseLocalVar, tags, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey, includeCurrentTags, includePendingTags, fileSortType, fileSortAsc, returnFileIds, returnHashes);

                        Events.ExecuteOnGetFilesSearchFiles(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetFilesSearchFilesDefaultImplementation(e, "/get_files/search_files", uriBuilderLocalVar.Path, tags, fileServiceKey, fileServiceKeys, deletedFileServiceKey, deletedFileServiceKeys, tagServiceKey, includeCurrentTags, includePendingTags, fileSortType, fileSortAsc, returnFileIds, returnHashes);
                Events.ExecuteOnErrorGetFilesSearchFiles(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetFilesSearchFilesApiResponse"/>
        /// </summary>
        public partial class GetFilesSearchFilesApiResponse : HydrusAPI.NET.Client.ApiResponse, IGetFilesSearchFilesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetFilesSearchFilesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetFilesSearchFilesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFilesSearchFilesApiResponse(ILogger<GetFilesSearchFilesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetFilesSearchFilesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFilesSearchFilesApiResponse(ILogger<GetFilesSearchFilesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public HydrusAPI.NET.Model.GetFilesSearchFiles200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<HydrusAPI.NET.Model.GetFilesSearchFiles200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out HydrusAPI.NET.Model.GetFilesSearchFiles200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 419 CustomHttpStatusCode419
            /// </summary>
            /// <returns></returns>
            public bool IsCustomHttpStatusCode419 => 419 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetFilesThumbnail(ref Option<int> fileId, ref Option<string> hash);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="hash"></param>
        /// <returns></returns>
        private void ValidateGetFilesThumbnail(Option<string> hash)
        {
            if (hash.IsSet && hash.Value == null)
                throw new ArgumentNullException(nameof(hash));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="hash"></param>
        private void AfterGetFilesThumbnailDefaultImplementation(IGetFilesThumbnailApiResponse apiResponseLocalVar, Option<int> fileId, Option<string> hash)
        {
            bool suppressDefaultLog = false;
            AfterGetFilesThumbnail(ref suppressDefaultLog, apiResponseLocalVar, fileId, hash);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="hash"></param>
        partial void AfterGetFilesThumbnail(ref bool suppressDefaultLog, IGetFilesThumbnailApiResponse apiResponseLocalVar, Option<int> fileId, Option<string> hash);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="hash"></param>
        private void OnErrorGetFilesThumbnailDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> fileId, Option<string> hash)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetFilesThumbnail(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, fileId, hash);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="hash"></param>
        partial void OnErrorGetFilesThumbnail(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> fileId, Option<string> hash);

        /// <summary>
        /// Get a file&#39;s thumbnail Retrieves the thumbnail for a specific file based on either a file ID or hash. Returns default icons if the thumbnail doesn&#39;t exist.
        /// </summary>
        /// <param name="fileId">Numerical file ID for the file. (optional)</param>
        /// <param name="hash">Hexadecimal SHA256 hash for the file. Can only be used if access to all files is granted. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesThumbnailApiResponse"/>&gt;</returns>
        public async Task<IGetFilesThumbnailApiResponse?> GetFilesThumbnailOrDefaultAsync(Option<int> fileId = default, Option<string> hash = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetFilesThumbnailAsync(fileId, hash, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get a file&#39;s thumbnail Retrieves the thumbnail for a specific file based on either a file ID or hash. Returns default icons if the thumbnail doesn&#39;t exist.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileId">Numerical file ID for the file. (optional)</param>
        /// <param name="hash">Hexadecimal SHA256 hash for the file. Can only be used if access to all files is granted. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesThumbnailApiResponse"/>&gt;</returns>
        public async Task<IGetFilesThumbnailApiResponse> GetFilesThumbnailAsync(Option<int> fileId = default, Option<string> hash = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetFilesThumbnail(hash);

                FormatGetFilesThumbnail(ref fileId, ref hash);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/get_files/thumbnail"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/get_files/thumbnail");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (fileId.IsSet)
                        parseQueryStringLocalVar["file_id"] = ClientUtils.ParameterToString(fileId.Value);

                    if (hash.IsSet)
                        parseQueryStringLocalVar["hash"] = ClientUtils.ParameterToString(hash.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Access-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Session-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "image/jpeg",
                        "image/png"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetFilesThumbnailApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetFilesThumbnailApiResponse>();
                        GetFilesThumbnailApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            case (200):
                            {
                                byte[] responseBytesArrayLocalVar = await httpResponseMessageLocalVar.Content.ReadAsByteArrayAsync(cancellationToken).ConfigureAwait(false);
                                System.IO.Stream responseContentStreamLocalVar = new System.IO.MemoryStream(responseBytesArrayLocalVar);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentStreamLocalVar, "/get_files/thumbnail", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/get_files/thumbnail", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetFilesThumbnailDefaultImplementation(apiResponseLocalVar, fileId, hash);

                        Events.ExecuteOnGetFilesThumbnail(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetFilesThumbnailDefaultImplementation(e, "/get_files/thumbnail", uriBuilderLocalVar.Path, fileId, hash);
                Events.ExecuteOnErrorGetFilesThumbnail(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetFilesThumbnailApiResponse"/>
        /// </summary>
        public partial class GetFilesThumbnailApiResponse : HydrusAPI.NET.Client.ApiResponse, IGetFilesThumbnailApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetFilesThumbnailApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetFilesThumbnailApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFilesThumbnailApiResponse(ILogger<GetFilesThumbnailApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetFilesThumbnailApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFilesThumbnailApiResponse(ILogger<GetFilesThumbnailApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public System.IO.Stream? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? ContentStream
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out System.IO.Stream? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetFilesThumbnailPath(ref Option<int> fileId, ref Option<string> hash, ref Option<bool> includeThumbnailFiletype);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="hash"></param>
        /// <returns></returns>
        private void ValidateGetFilesThumbnailPath(Option<string> hash)
        {
            if (hash.IsSet && hash.Value == null)
                throw new ArgumentNullException(nameof(hash));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="hash"></param>
        /// <param name="includeThumbnailFiletype"></param>
        private void AfterGetFilesThumbnailPathDefaultImplementation(IGetFilesThumbnailPathApiResponse apiResponseLocalVar, Option<int> fileId, Option<string> hash, Option<bool> includeThumbnailFiletype)
        {
            bool suppressDefaultLog = false;
            AfterGetFilesThumbnailPath(ref suppressDefaultLog, apiResponseLocalVar, fileId, hash, includeThumbnailFiletype);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="hash"></param>
        /// <param name="includeThumbnailFiletype"></param>
        partial void AfterGetFilesThumbnailPath(ref bool suppressDefaultLog, IGetFilesThumbnailPathApiResponse apiResponseLocalVar, Option<int> fileId, Option<string> hash, Option<bool> includeThumbnailFiletype);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="hash"></param>
        /// <param name="includeThumbnailFiletype"></param>
        private void OnErrorGetFilesThumbnailPathDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> fileId, Option<string> hash, Option<bool> includeThumbnailFiletype)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetFilesThumbnailPath(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, fileId, hash, includeThumbnailFiletype);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fileId"></param>
        /// <param name="hash"></param>
        /// <param name="includeThumbnailFiletype"></param>
        partial void OnErrorGetFilesThumbnailPath(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> fileId, Option<string> hash, Option<bool> includeThumbnailFiletype);

        /// <summary>
        /// Get the local thumbnail path for a file. Returns the local file system path to the thumbnail of the specified file. Optionally includes the thumbnail&#39;s filetype.
        /// </summary>
        /// <param name="fileId"> (optional)</param>
        /// <param name="hash"> (optional)</param>
        /// <param name="includeThumbnailFiletype"> (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesThumbnailPathApiResponse"/>&gt;</returns>
        public async Task<IGetFilesThumbnailPathApiResponse?> GetFilesThumbnailPathOrDefaultAsync(Option<int> fileId = default, Option<string> hash = default, Option<bool> includeThumbnailFiletype = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetFilesThumbnailPathAsync(fileId, hash, includeThumbnailFiletype, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get the local thumbnail path for a file. Returns the local file system path to the thumbnail of the specified file. Optionally includes the thumbnail&#39;s filetype.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fileId"> (optional)</param>
        /// <param name="hash"> (optional)</param>
        /// <param name="includeThumbnailFiletype"> (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFilesThumbnailPathApiResponse"/>&gt;</returns>
        public async Task<IGetFilesThumbnailPathApiResponse> GetFilesThumbnailPathAsync(Option<int> fileId = default, Option<string> hash = default, Option<bool> includeThumbnailFiletype = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetFilesThumbnailPath(hash);

                FormatGetFilesThumbnailPath(ref fileId, ref hash, ref includeThumbnailFiletype);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/get_files/thumbnail_path"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/get_files/thumbnail_path");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (fileId.IsSet)
                        parseQueryStringLocalVar["file_id"] = ClientUtils.ParameterToString(fileId.Value);

                    if (hash.IsSet)
                        parseQueryStringLocalVar["hash"] = ClientUtils.ParameterToString(hash.Value);

                    if (includeThumbnailFiletype.IsSet)
                        parseQueryStringLocalVar["include_thumbnail_filetype"] = ClientUtils.ParameterToString(includeThumbnailFiletype.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Access-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Session-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetFilesThumbnailPathApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetFilesThumbnailPathApiResponse>();
                        GetFilesThumbnailPathApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/get_files/thumbnail_path", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetFilesThumbnailPathDefaultImplementation(apiResponseLocalVar, fileId, hash, includeThumbnailFiletype);

                        Events.ExecuteOnGetFilesThumbnailPath(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetFilesThumbnailPathDefaultImplementation(e, "/get_files/thumbnail_path", uriBuilderLocalVar.Path, fileId, hash, includeThumbnailFiletype);
                Events.ExecuteOnErrorGetFilesThumbnailPath(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetFilesThumbnailPathApiResponse"/>
        /// </summary>
        public partial class GetFilesThumbnailPathApiResponse : HydrusAPI.NET.Client.ApiResponse, IGetFilesThumbnailPathApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetFilesThumbnailPathApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetFilesThumbnailPathApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFilesThumbnailPathApiResponse(ILogger<GetFilesThumbnailPathApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetFilesThumbnailPathApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFilesThumbnailPathApiResponse(ILogger<GetFilesThumbnailPathApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public HydrusAPI.NET.Model.GetFilesThumbnailPath200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<HydrusAPI.NET.Model.GetFilesThumbnailPath200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out HydrusAPI.NET.Model.GetFilesThumbnailPath200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetLocalFileStorageLocationsDefaultImplementation(IGetLocalFileStorageLocationsApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetLocalFileStorageLocations(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetLocalFileStorageLocations(ref bool suppressDefaultLog, IGetLocalFileStorageLocationsApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorGetLocalFileStorageLocationsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetLocalFileStorageLocations(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorGetLocalFileStorageLocations(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Get local file storage locations Returns the local file storage locations as seen under **database-&gt;migrate files**.
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLocalFileStorageLocationsApiResponse"/>&gt;</returns>
        public async Task<IGetLocalFileStorageLocationsApiResponse?> GetLocalFileStorageLocationsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetLocalFileStorageLocationsAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get local file storage locations Returns the local file storage locations as seen under **database-&gt;migrate files**.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetLocalFileStorageLocationsApiResponse"/>&gt;</returns>
        public async Task<IGetLocalFileStorageLocationsApiResponse> GetLocalFileStorageLocationsAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/get_files/local_file_storage_locations"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/get_files/local_file_storage_locations");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Access-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    ApiKeyToken apiKeyTokenLocalVar2 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Hydrus-Client-API-Session-Key", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar2);
                    apiKeyTokenLocalVar2.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetLocalFileStorageLocationsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetLocalFileStorageLocationsApiResponse>();
                        GetLocalFileStorageLocationsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/get_files/local_file_storage_locations", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetLocalFileStorageLocationsDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetLocalFileStorageLocations(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetLocalFileStorageLocationsDefaultImplementation(e, "/get_files/local_file_storage_locations", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetLocalFileStorageLocations(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetLocalFileStorageLocationsApiResponse"/>
        /// </summary>
        public partial class GetLocalFileStorageLocationsApiResponse : HydrusAPI.NET.Client.ApiResponse, IGetLocalFileStorageLocationsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetLocalFileStorageLocationsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetLocalFileStorageLocationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetLocalFileStorageLocationsApiResponse(ILogger<GetLocalFileStorageLocationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetLocalFileStorageLocationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetLocalFileStorageLocationsApiResponse(ILogger<GetLocalFileStorageLocationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public HydrusAPI.NET.Model.GetLocalFileStorageLocations200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<HydrusAPI.NET.Model.GetLocalFileStorageLocations200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out HydrusAPI.NET.Model.GetLocalFileStorageLocations200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
